#include "twoPhaseEulerAdvection.hpp"

#include <utility>
#include "eos/perfectGas.hpp"
#include "eos/stiffenedGas.hpp"
#include "eos/twoPhase.hpp"
#include "finiteVolume/compressibleFlowFields.hpp"
#include "flowProcess.hpp"
#include "domain/region.hpp"
#include "domain/subDomain.hpp"
#include "parameters/emptyParameters.hpp"
#include "utilities/petscSupport.hpp"

#include <signal.h>

#define NOTE0EXIT(S, ...) {PetscFPrintf(MPI_COMM_WORLD, stderr,                                     \
  "\x1b[1m(%s:%d, %s)\x1b[0m\n  \x1b[1m\x1b[90mexiting:\x1b[0m " S "\n",    \
  __FILE__, __LINE__, __FUNCTION__, ##__VA_ARGS__); exit(0);}

static inline void NormVector(PetscInt dim, const PetscReal *in, PetscReal *out) {
    PetscReal mag = 0.0;
    for (PetscInt d = 0; d < dim; d++) {
        mag += in[d] * in[d];
    }
    mag = PetscSqrtReal(mag);
    for (PetscInt d = 0; d < dim; d++) {
        out[d] = in[d] / mag;
    }
}

static inline PetscReal MagVector(PetscInt dim, const PetscReal *in) {
    PetscReal mag = 0.0;
    for (PetscInt d = 0; d < dim; d++) {
        mag += in[d] * in[d];
    }
    return PetscSqrtReal(mag);
}

PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::FormFunctionGas(SNES snes, Vec x, Vec F, void *ctx) {
    auto decodeDataStruct = (DecodeDataStructGas *)ctx;
    const PetscReal *ax;
    PetscReal *aF;
    VecGetArrayRead(x, &ax) >> utilities::PetscUtilities::checkError;
    // ax = [rhog, rhol, T]
    PetscReal rhoG = ax[0];
    PetscReal rhoL = ax[1];
    PetscReal T = ax[2];
    VecRestoreArrayRead(x, &ax) >> utilities::PetscUtilities::checkError;

    PetscReal gammaG = decodeDataStruct->gamG;
    PetscReal gammaL = decodeDataStruct->gamL;
    PetscReal Yg = decodeDataStruct->Yg;
    PetscReal Yl = decodeDataStruct->Yl;
    PetscReal rho = decodeDataStruct->density;
    PetscReal e = decodeDataStruct->internalEnergy;
    PetscReal cvG = decodeDataStruct->cvG;
    PetscReal cpL = decodeDataStruct->cpL;
    PetscReal p0L = decodeDataStruct->p0L;

    VecGetArray(F, &aF) >> utilities::PetscUtilities::checkError;

    aF[0] = (cpL*(-1 + gammaL)*rhoL*T)/gammaL - p0L - cvG*(-1 + gammaG)*rhoG*T;
    aF[1] = -(e*rhoL) + cvG*rhoL*T*Yg + (p0L + (cpL*rhoL*T)/gammaL)*Yl;
    aF[2] = -(rhoG*rhoL) + rho*rhoL*Yg + rho*rhoG*Yl;

    VecRestoreArray(F, &aF) >> utilities::PetscUtilities::checkError;
    return 0;
}

PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::FormJacobianGas(SNES snes, Vec x, Mat J, Mat P, void *ctx) {
    auto decodeDataStruct = (DecodeDataStructGas *)ctx;

    const PetscReal *ax;
    VecGetArrayRead(x, &ax) >> utilities::PetscUtilities::checkError;
    // ax = [rhog, rhol, T]
    const PetscReal rhoG = ax[0];
    const PetscReal rhoL = ax[1];
    const PetscReal T = ax[2];
    VecRestoreArrayRead(x, &ax) >> utilities::PetscUtilities::checkError;

    const PetscReal gammaG = decodeDataStruct->gamG;
    const PetscReal gammaL = decodeDataStruct->gamL;
    const PetscReal Yg = decodeDataStruct->Yg;
    const PetscReal Yl = decodeDataStruct->Yl;
    const PetscReal rho = decodeDataStruct->density;
    const PetscReal e = decodeDataStruct->internalEnergy;
    const PetscReal cvG = decodeDataStruct->cvG;
    const PetscReal cpL = decodeDataStruct->cpL;
//    PetscReal p0L = decodeDataStruct->p0L;

    PetscScalar *v;
    MatDenseGetArray(P, &v) >> utilities::PetscUtilities::checkError;
    v[0] = -(cvG*(-1 + gammaG)*T);
    v[1] = (cpL*(-1 + gammaL)*T)/gammaL;
    v[2] = -(cvG*(-1 + gammaG)*rhoG) + (cpL*(-1 + gammaL)*rhoL)/gammaL;
    v[3] = 0;
    v[4] = -e + cvG*T*Yg + (cpL*T*Yl)/gammaL;
    v[5] = cvG*rhoL*Yg + (cpL*rhoL*Yl)/gammaL;
    v[6] = -rhoL + rho*Yl;
    v[7] = -rhoG + rho*Yg;
    v[8] = 0;
    MatDenseRestoreArray(P, &v) >> utilities::PetscUtilities::checkError;

    if (J != P) {
      MatCopy(P, J, SAME_NONZERO_PATTERN);
    }
    return 0;
}

PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::FormFunctionStiff(SNES snes, Vec x, Vec F, void *ctx) {
    auto decodeDataStruct = (DecodeDataStructStiff *)ctx;
    const PetscReal *ax;
    PetscReal *aF;
    VecGetArrayRead(x, &ax);
    // ax = [rhog, rhol, eg, el]
    PetscReal rhoG = ax[0];
    PetscReal rhoL = ax[1];
    PetscReal eG = ax[2];
    PetscReal eL = ax[3];

    PetscReal gamma1 = decodeDataStruct->gam1;
    PetscReal gamma2 = decodeDataStruct->gam2;
    PetscReal Y1 = decodeDataStruct->Yg;
    PetscReal Y2 = decodeDataStruct->Yl;
    PetscReal rho = decodeDataStruct->rhotot;
    PetscReal e = decodeDataStruct->etot;
    PetscReal cp1 = decodeDataStruct->cpg;
    PetscReal cp2 = decodeDataStruct->cpl;
    PetscReal p01 = decodeDataStruct->p0g;
    PetscReal p02 = decodeDataStruct->p0l;

    VecGetArray(F, &aF);
    aF[0] = (gamma1 - 1) * eG * rhoG - gamma1 * p01 - (gamma2 - 1) * eL * rhoL + gamma2 * p02;  // pG - pL = 0, pressure equilibrium
    aF[1] = gamma1 / cp1 * rhoL * (eG * rhoG - p01) - gamma2 / cp2 * rhoG * (eL * rhoL - p02);  // TG - TL = 0, temperature equilibrium
    aF[2] = Y1 * rho * rhoL + Y2 * rho * rhoG - rhoG * rhoL;
    aF[3] = Y1 * eG + Y2 * eL - e;

//printf("%+e\t%+e\t%+e\t%+e\n", rhoG, rhoL, eG, eL);

    VecRestoreArrayRead(x, &ax);
    VecRestoreArray(F, &aF);
    return 0;
}

PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::FormJacobianStiff(SNES snes, Vec x, Mat J, Mat P, void *ctx) {
    auto decodeDataStruct = (DecodeDataStructStiff *)ctx;
    const PetscReal *ax;
    PetscReal v[16];
    PetscInt row[4] = {0, 1, 2, 3}, col[4] = {0, 1, 2, 3};
    VecGetArrayRead(x, &ax);
    // ax = [rhog, rhol, eg, el]
    PetscReal rhoG = ax[0];
    PetscReal rhoL = ax[1];
    PetscReal eG = ax[2];
    PetscReal eL = ax[3];

    PetscReal gamma1 = decodeDataStruct->gam1;
    PetscReal gamma2 = decodeDataStruct->gam2;
    PetscReal Y1 = decodeDataStruct->Yg;
    PetscReal Y2 = decodeDataStruct->Yl;
    PetscReal rho = decodeDataStruct->rhotot;
    //    PetscReal e = decodeDataStruct->etot;
    PetscReal cp1 = decodeDataStruct->cpg;
    PetscReal cp2 = decodeDataStruct->cpl;
    PetscReal p01 = decodeDataStruct->p0g;
    PetscReal p02 = decodeDataStruct->p0l;

    // need to check Jacobian, not getting correct solution
    v[0] = (gamma1 - 1) * eG;
    v[1] = -(gamma2 - 1) * eL;
    v[2] = (gamma1 - 1) * rhoG;
    v[3] = -(gamma2 - 1) * rhoL;
    v[4] = gamma1 / cp1 * eG * rhoL - gamma2 / cp2 * eL * rhoL + gamma2 / cp2 * p02;
    v[5] = gamma1 / cp1 * eG * rhoG - gamma1 / cp1 * p01 - gamma2 / cp2 * eL * rhoG;
    v[6] = gamma1 / cp1 * rhoG * rhoL;
    v[7] = -gamma2 / cp2 * rhoG * rhoL;
    v[8] = Y2 * rho - rhoL;
    v[9] = Y1 * rho - rhoG;
    v[10] = 0.0;
    v[11] = 0.0;
    v[12] = 0.0;
    v[13] = 0.0;
    v[14] = Y1;
    v[15] = Y2;
    VecRestoreArrayRead(x, &ax);
    MatSetValues(P, 4, row, 4, col, v, INSERT_VALUES);
    MatAssemblyBegin(P, MAT_FINAL_ASSEMBLY);
    MatAssemblyEnd(P, MAT_FINAL_ASSEMBLY);
    if (J != P) {
        MatSetValues(J, 4, row, 4, col, v, INSERT_VALUES);
        MatAssemblyBegin(J, MAT_FINAL_ASSEMBLY);
        MatAssemblyEnd(J, MAT_FINAL_ASSEMBLY);
    }
    return 0;
}

ablate::finiteVolume::processes::TwoPhaseEulerAdvection::TwoPhaseEulerAdvection(std::shared_ptr<eos::EOS> eosTwoPhase, const std::shared_ptr<parameters::Parameters> &parametersIn,
                                                                                std::shared_ptr<fluxCalculator::FluxCalculator> fluxCalculatorGasGas,
                                                                                std::shared_ptr<fluxCalculator::FluxCalculator> fluxCalculatorGasLiquid,
                                                                                std::shared_ptr<fluxCalculator::FluxCalculator> fluxCalculatorLiquidGas,
                                                                                std::shared_ptr<fluxCalculator::FluxCalculator> fluxCalculatorLiquidLiquid)
    : eosTwoPhase(std::move(eosTwoPhase)),
      fluxCalculatorGasGas(std::move(fluxCalculatorGasGas)),
      fluxCalculatorGasLiquid(std::move(fluxCalculatorGasLiquid)),
      fluxCalculatorLiquidGas(std::move(fluxCalculatorLiquidGas)),
      fluxCalculatorLiquidLiquid(std::move(fluxCalculatorLiquidLiquid)) {
    auto parameters = ablate::parameters::EmptyParameters::Check(parametersIn);
    // check that eos is twoPhase
    if (this->eosTwoPhase) {
        auto twoPhaseEOS = std::dynamic_pointer_cast<eos::TwoPhase>(this->eosTwoPhase);
        // populate component eoses
        if (twoPhaseEOS) {
            eosGas = twoPhaseEOS->GetEOSGas();
            eosLiquid = twoPhaseEOS->GetEOSLiquid();
        } else {
            throw std::invalid_argument("invalid EOS. twoPhaseEulerAdvection requires TwoPhase equation of state.");
        }
    }

    // If there is a flux calculator assumed advection
    if (this->fluxCalculatorGasGas) {
        // cfl
        timeStepData.cfl = parameters->Get<PetscReal>("cfl", 0.5);
    }
}

ablate::finiteVolume::processes::TwoPhaseEulerAdvection::~TwoPhaseEulerAdvection() {}

void ComputeFieldGradientDM(ablate::finiteVolume::FiniteVolumeSolver &flow, Vec faceGeomVec, Vec cellGeomVec, const std::string fieldName, DM *gradDM) {

  ablate::domain::Field field = flow.GetSubDomain().GetField(fieldName);
  PetscObject petscField = flow.GetSubDomain().GetPetscFieldObject(field);
  PetscFV petscFieldFV = (PetscFV)petscField;

  DMLabel regionLabel = nullptr;
  PetscInt regionValue = PETSC_DECIDE;
  ablate::domain::Region::GetLabel(flow.GetRegion(), flow.GetSubDomain().GetDM(), regionLabel, regionValue);

  ComputeGradientFVM(flow.GetSubDomain().GetFieldDM(field), regionLabel, regionValue, petscFieldFV, faceGeomVec, cellGeomVec, gradDM) >> ablate::utilities::PetscUtilities::checkError;
}


void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::Setup(ablate::finiteVolume::FiniteVolumeSolver &flow) {
    // Before each step, compute the alpha
    auto multiphasePreStage = std::bind(&ablate::finiteVolume::processes::TwoPhaseEulerAdvection::MultiphaseFlowPreStage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
    flow.RegisterPreStage(multiphasePreStage);

    // Create the decoder based upon the eoses
    decoder = CreateTwoPhaseDecoder(flow.GetSubDomain().GetDimensions(), eosGas, eosLiquid);

    // Currently, no option for species advection
//    flow.RegisterRHSFunction(CompressibleFlowCompleteFlux, this);
    flow.RegisterRHSFunction(CompressibleFlowComputeEulerFlux, this, CompressibleFlowFields::EULER_FIELD, {VOLUME_FRACTION_FIELD, DENSITY_VF_FIELD, CompressibleFlowFields::EULER_FIELD}, {});
    flow.RegisterRHSFunction(CompressibleFlowComputeVFFlux, this, DENSITY_VF_FIELD, {VOLUME_FRACTION_FIELD, DENSITY_VF_FIELD, CompressibleFlowFields::EULER_FIELD}, {});
    flow.RegisterComputeTimeStepFunction(ComputeCflTimeStep, &timeStepData, "cfl");
    timeStepData.computeSpeedOfSound = eosTwoPhase->GetThermodynamicFunction(eos::ThermodynamicProperty::SpeedOfSound, flow.GetSubDomain().GetFields());

    if (flow.GetSubDomain().ContainsField(CompressibleFlowFields::VELOCITY_FIELD) && (flow.GetSubDomain().GetField(CompressibleFlowFields::VELOCITY_FIELD).location == ablate::domain::FieldLocation::AUX)) {
      auxUpdateFields.push_back(CompressibleFlowFields::VELOCITY_FIELD);
    }

    if (flow.GetSubDomain().ContainsField(CompressibleFlowFields::TEMPERATURE_FIELD) && (flow.GetSubDomain().GetField(CompressibleFlowFields::TEMPERATURE_FIELD).location == ablate::domain::FieldLocation::AUX)) {
      auxUpdateFields.push_back(CompressibleFlowFields::TEMPERATURE_FIELD);
    }

    if (flow.GetSubDomain().ContainsField(CompressibleFlowFields::PRESSURE_FIELD) && (flow.GetSubDomain().GetField(CompressibleFlowFields::PRESSURE_FIELD).location == ablate::domain::FieldLocation::AUX)) {
      auxUpdateFields.push_back(CompressibleFlowFields::PRESSURE_FIELD);
    }

    // There's more work that needs to be done before VOLUME_FRACTION_FIELD can be in the AUX field.
    if (flow.GetSubDomain().ContainsField(VOLUME_FRACTION_FIELD) && (flow.GetSubDomain().GetField(VOLUME_FRACTION_FIELD).location == ablate::domain::FieldLocation::AUX)) {
      auxUpdateFields.push_back(VOLUME_FRACTION_FIELD);
    }

    if (auxUpdateFields.size() > 0) {
      flow.RegisterAuxFieldUpdate(
            UpdateAuxFieldsTwoPhase, this, auxUpdateFields, {VOLUME_FRACTION_FIELD, DENSITY_VF_FIELD, CompressibleFlowFields::EULER_FIELD});
    }

}

#include <signal.h>
// Update the volume fraction, velocity, temperature, and pressure fields (if they exist).
PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::UpdateAuxFieldsTwoPhase(PetscReal time, PetscInt dim, const PetscFVCellGeom *cellGeom, const PetscInt uOff[],
                                                                                                   const PetscScalar *conservedValues, const PetscInt aOff[], PetscScalar *auxField, void *ctx) {
    PetscFunctionBeginUser;

    if (!auxField) PetscFunctionReturn(0);

    auto twoPhaseEulerAdvection = (TwoPhaseEulerAdvection *)ctx;

    // For cell center, the norm is unity
    PetscReal norm[3];
    norm[0] = 1;
    norm[1] = 1;
    norm[2] = 1;

    PetscReal density = 1.0;
    PetscReal densityG = 0.0;
    PetscReal densityL = 0.0;
    PetscReal normalVelocity = 0.0;  // uniform velocity in cell
    PetscReal velocity[3] = {0.0, 0.0, 0.0};
    PetscReal internalEnergy = 0.0;
    PetscReal internalEnergyG = 0.0;
    PetscReal internalEnergyL = 0.0;
    PetscReal aG = 0.0;
    PetscReal aL = 0.0;
    PetscReal MG = 0.0;
    PetscReal ML = 0.0;
    PetscReal p = 0.0;  // pressure equilibrium
    PetscReal T = 0.0;  // temperature equilibrium, Tg = TL
    PetscReal alpha = 0.0;

    if (conservedValues) {
      twoPhaseEulerAdvection->decoder->DecodeTwoPhaseEulerState(
        dim, uOff, conservedValues, norm, &density, &densityG, &densityL, &normalVelocity, velocity, &internalEnergy, &internalEnergyG, &internalEnergyL, &aG, &aL, &MG, &ML, &p, &T, &alpha);

      density = conservedValues[CompressibleFlowFields::RHO];
      for (PetscInt d = 0; d < dim; d++) velocity[d] = conservedValues[CompressibleFlowFields::RHOU + d] / density;

    }

    auto fields = twoPhaseEulerAdvection->auxUpdateFields.data();

    for (std::size_t f = 0; f < twoPhaseEulerAdvection->auxUpdateFields.size(); ++f) {
      if (fields[f] == CompressibleFlowFields::VELOCITY_FIELD) {
        for (PetscInt d = 0; d < dim; d++) {
          auxField[aOff[f] + d] = velocity[d];
        }
      }
      else if (fields[f] == CompressibleFlowFields::TEMPERATURE_FIELD) {
        auxField[aOff[f]] = T;
      }
      else if (fields[f] == CompressibleFlowFields::PRESSURE_FIELD) {
        auxField[aOff[f]] = p;
      }
      else if (fields[f] == VOLUME_FRACTION_FIELD) { // In case it's ever moved to the AUX vector
        auxField[aOff[f]] = alpha;
      }
    }

    PetscFunctionReturn(0);
}

PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::MultiphaseFlowPreStage(TS flowTs, ablate::solver::Solver &solver, PetscReal stagetime) {
    PetscFunctionBegin;
    // Get flow field data
    const auto &fvSolver = dynamic_cast<ablate::finiteVolume::FiniteVolumeSolver &>(solver);
    ablate::domain::Range cellRange;
    fvSolver.GetCellRangeWithoutGhost(cellRange);
    PetscInt dim;
    PetscCall(DMGetDimension(fvSolver.GetSubDomain().GetDM(), &dim));
    const auto &eulerOffset = fvSolver.GetSubDomain().GetField(CompressibleFlowFields::EULER_FIELD).offset;  // need this to get uOff
    const auto &vfOffset = fvSolver.GetSubDomain().GetField(VOLUME_FRACTION_FIELD).offset;
    const auto &rhoAlphaOffset = fvSolver.GetSubDomain().GetField(DENSITY_VF_FIELD).offset;

    DM dm = fvSolver.GetSubDomain().GetDM();
    Vec globFlowVec;
    PetscCall(TSGetSolution(flowTs, &globFlowVec));

    PetscScalar *flowArray;
    PetscCall(VecGetArray(globFlowVec, &flowArray));

    PetscInt uOff[3];
    uOff[0] = vfOffset;
    uOff[1] = rhoAlphaOffset;
    uOff[2] = eulerOffset;

    // For cell center, the norm is unity
    PetscReal norm[3];
    norm[0] = 1;
    norm[1] = 1;
    norm[2] = 1;

    for (PetscInt i = cellRange.start; i < cellRange.end; ++i) {
        const PetscInt cell = cellRange.GetPoint(i);
        PetscScalar *allFields = nullptr;
        DMPlexPointLocalRef(dm, cell, flowArray, &allFields) >> utilities::PetscUtilities::checkError;
        auto density = allFields[ablate::finiteVolume::CompressibleFlowFields::RHO];
        PetscReal velocity[3];
        for (PetscInt d = 0; d < dim; d++) {
            velocity[d] = allFields[ablate::finiteVolume::CompressibleFlowFields::RHOU + d] / density;
        }
        // Decode state
        //         PetscReal density;
        PetscReal densityG;
        PetscReal densityL;
        PetscReal normalVelocity;  // uniform velocity in cell
                                   //         PetscReal velocity[3];
        PetscReal internalEnergy;
        PetscReal internalEnergyG;
        PetscReal internalEnergyL;
        PetscReal aG;
        PetscReal aL;
        PetscReal MG;
        PetscReal ML;
        PetscReal p;  // pressure equilibrium
        PetscReal t;
        PetscReal alpha;
        decoder->DecodeTwoPhaseEulerState(
            dim, uOff, allFields, norm, &density, &densityG, &densityL, &normalVelocity, velocity, &internalEnergy, &internalEnergyG, &internalEnergyL, &aG, &aL, &MG, &ML, &p, &t, &alpha);
        // maybe save other values for use later, would interpolation to the face be the same as calculating at face?
        allFields[uOff[0]] = alpha;  // sets volumeFraction field, does every iteration of time step (euler=1, rk=4)
//PetscReal x[3];
//DMPlexComputeCellGeometryFVM(dm, cell, NULL, x, NULL) >> ablate::utilities::PetscUtilities::checkError;
//fprintf(f1, "%.16e\t%.16e\t%.16e\t%.16e\t%.16e\t%.16e\t%.16e\t%.16e\t%.16e\n", x[0], x[1], alpha, t, p, densityG, densityL, internalEnergyG, internalEnergyL);
//if (cell==3104) printf("%+f\t%+f\n", x[0], x[1]);

//        if (alpha < 0.0 || alpha > 1.0) {
//          if (alpha<0.0) printf("%.16e\n", alpha);
//          else printf("%.16e\n", alpha-1.0);
//          throw std::runtime_error("Volume fraction of " + std::to_string(alpha) + " is out-of-bounds.");
//        }
    }
//fclose(f1);
//NOTE0EXIT("");
    // clean up
    fvSolver.RestoreRange(cellRange);
    PetscFunctionReturn(0);
}

double ablate::finiteVolume::processes::TwoPhaseEulerAdvection::ComputeCflTimeStep(TS ts, ablate::finiteVolume::FiniteVolumeSolver &flow, void *ctx) {
    // Get the dm and current solution vector
    DM dm;
    TSGetDM(ts, &dm) >> utilities::PetscUtilities::checkError;
    Vec v;
    TSGetSolution(ts, &v) >> utilities::PetscUtilities::checkError;

    // Get the flow param
    auto timeStepData = (TimeStepData *)ctx;

    // Get the fv geom
    PetscReal minCellRadius;
    DMPlexGetGeometryFVM(dm, NULL, NULL, &minCellRadius) >> utilities::PetscUtilities::checkError;

    // Get the valid cell range over this region
    ablate::domain::Range cellRange;
    flow.GetCellRange(cellRange);

    const PetscScalar *x;
    VecGetArrayRead(v, &x) >> utilities::PetscUtilities::checkError;

    // Get the dim from the dm
    PetscInt dim;
    DMGetDimension(dm, &dim) >> utilities::PetscUtilities::checkError;

    // assume the smallest cell is the limiting factor for now
    const PetscReal dx = 2.0 * minCellRadius;

    // Get field location for euler and densityYi
    auto eulerId = flow.GetSubDomain().GetField(ablate::finiteVolume::CompressibleFlowFields::EULER_FIELD).id;

    // March over each cell
    PetscReal dtMin = 1000.0;
    for (PetscInt c = cellRange.start; c < cellRange.end; ++c) {
        PetscInt cell = cellRange.points ? cellRange.points[c] : c;

        const PetscReal *euler;
        const PetscReal *conserved = NULL;
        DMPlexPointGlobalFieldRead(dm, cell, eulerId, x, &euler) >> utilities::PetscUtilities::checkError;
        DMPlexPointGlobalRead(dm, cell, x, &conserved) >> utilities::PetscUtilities::checkError;

        if (euler) {  // must be real cell and not ghost
            PetscReal rho = euler[CompressibleFlowFields::RHO];

            // Get the speed of sound from the eos
            PetscReal a;
            timeStepData->computeSpeedOfSound.function(conserved, &a, timeStepData->computeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;

            PetscReal velSum = 0.0;
            for (PetscInt d = 0; d < dim; d++) {
                velSum += PetscAbsReal(euler[CompressibleFlowFields::RHOU + d]) / rho;
            }
            PetscReal dt = timeStepData->cfl * dx / (a + velSum);

            dtMin = PetscMin(dtMin, dt);
        }
    }
    VecRestoreArrayRead(v, &x) >> utilities::PetscUtilities::checkError;
    flow.RestoreRange(cellRange);
    return dtMin;
}



PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::CompressibleFlowCompleteFlux(const ablate::finiteVolume::FiniteVolumeSolver &flow, DM dm, PetscReal time, Vec locXVec, Vec locFVec, void* ctx) {

  PetscFunctionBeginUser;
//  auto flow = (ablate::finiteVolume::FiniteVolumeSolver *)ctx;
//  auto twoPhaseEulerAdvection = (TwoPhaseEulerAdvection *)ctx;
  NOTE0EXIT("");

  PetscFunctionReturn(0);

}


PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::CompressibleFlowComputeEulerFlux(PetscInt dim, const PetscFVFaceGeom *fg, const PetscInt *uOff, const PetscScalar *fieldL,
                                                                                                         const PetscScalar *fieldR, const PetscInt *aOff, const PetscScalar *auxL,
                                                                                                         const PetscScalar *auxR, PetscScalar *flux, void *ctx) {
    PetscFunctionBeginUser;
    auto twoPhaseEulerAdvection = (TwoPhaseEulerAdvection *)ctx;
    // Compute the norm of cell face
    PetscReal norm[3];
    NormVector(dim, fg->normal, norm);
    const PetscReal areaMag = MagVector(dim, fg->normal);

    // Decode left and right states
    PetscReal densityL = 0.0;
    PetscReal densityG_L = 0.0;
    PetscReal densityL_L = 0.0;
    PetscReal normalVelocityL = 0.0;  // uniform velocity in cell
    PetscReal velocityL[3] = {0.0, 0.0, 0.0};
    PetscReal internalEnergyL = 0.0;
    PetscReal internalEnergyG_L = 0.0;
    PetscReal internalEnergyL_L = 0.0;
    PetscReal aG_L = 0.0;
    PetscReal aL_L = 0.0;
    PetscReal MG_L = 0.0;
    PetscReal ML_L = 0.0;
    PetscReal pL = 0.0;  // pressure equilibrium
    PetscReal tL = 0.0;
    PetscReal alphaL = 0.0;
    twoPhaseEulerAdvection->decoder->DecodeTwoPhaseEulerState(dim,
                                                              uOff,
                                                              fieldL,
                                                              norm,
                                                              &densityL,
                                                              &densityG_L,
                                                              &densityL_L,
                                                              &normalVelocityL,
                                                              velocityL,
                                                              &internalEnergyL,
                                                              &internalEnergyG_L,
                                                              &internalEnergyL_L,
                                                              &aG_L,
                                                              &aL_L,
                                                              &MG_L,
                                                              &ML_L,
                                                              &pL,
                                                              &tL,
                                                              &alphaL);

    PetscReal densityR = 0.0;
    PetscReal densityG_R = 0.0;
    PetscReal densityL_R = 0.0;
    PetscReal normalVelocityR = 0.0;
    PetscReal velocityR[3] = {0.0, 0.0, 0.0};
    PetscReal internalEnergyR = 0.0;
    PetscReal internalEnergyG_R = 0.0;
    PetscReal internalEnergyL_R = 0.0;
    PetscReal aG_R = 0.0;
    PetscReal aL_R = 0.0;
    PetscReal MG_R = 0.0;
    PetscReal ML_R = 0.0;
    PetscReal pR = 0.0;
    PetscReal tR = 0.0;
    PetscReal alphaR = 0.0;

    twoPhaseEulerAdvection->decoder->DecodeTwoPhaseEulerState(dim,
                                                              uOff,
                                                              fieldR,
                                                              norm,
                                                              &densityR,
                                                              &densityG_R,
                                                              &densityL_R,
                                                              &normalVelocityR,
                                                              velocityR,
                                                              &internalEnergyR,
                                                              &internalEnergyG_R,
                                                              &internalEnergyL_R,
                                                              &aG_R,
                                                              &aL_R,
                                                              &MG_R,
                                                              &ML_R,
                                                              &pR,
                                                              &tR,
                                                              &alphaR);


    // Fraction of each face
//    const PetscReal alphaGG = PetscMin(alphaR, alphaL);
//    const PetscReal alphaGL = PetscAbs(alphaL - alphaR);
//    const PetscReal alphaLL = 1.0 - alphaGG - alphaGL;

    // call flux calculator 3 times, gas-gas, gas-liquid, liquid-liquid regions

    // Gas-Gas
/*    PetscReal massFluxGG = 0.0, p12GG = 0.0;
    fluxCalculator::Direction directionGG = fluxCalculator::Direction::NA;
    if (alphaGG > PETSC_SMALL) {
     directionGG = twoPhaseEulerAdvection->fluxCalculatorGasGas->GetFluxCalculatorFunction()(
        twoPhaseEulerAdvection->fluxCalculatorGasGas->GetFluxCalculatorContext(), normalVelocityL, aG_L, densityG_L, pL, normalVelocityR, aG_R, densityG_R, pR, &massFluxGG, &p12GG);
    }



    // Liquid-Liquid
    PetscReal massFluxLL = 0.0, p12LL = 0.0;
    fluxCalculator::Direction directionLL = fluxCalculator::Direction::NA;
    if ( alphaLL > PETSC_SMALL) {
      try {
        directionLL = twoPhaseEulerAdvection->fluxCalculatorLiquidLiquid->GetFluxCalculatorFunction()(
            twoPhaseEulerAdvection->fluxCalculatorLiquidLiquid->GetFluxCalculatorContext(), normalVelocityL, aL_L, densityL_L, pL, normalVelocityR, aL_R, densityL_R, pR, &massFluxLL, &p12LL);
      } catch (const std::runtime_error& error) {
        // In cases where one of the cells has a very small liquid volume fraction the pstar solver might not have a root.
        if ( alphaLL > 1e-5) {
          throw std::runtime_error("Could not calculate the LL-flux with alphaLL = " + std::to_string(alphaLL) + ".");
        }
        massFluxLL = 0.0;
        p12LL = 0.0;
      }

    }


    // Liquid-Gas
    PetscReal massFluxGL = 0.0, p12GL = 0.0;
    fluxCalculator::Direction directionGL = fluxCalculator::Direction::NA;
    if (alphaGL > PETSC_SMALL) {
      if (alphaL > alphaR) {
          // gas on left, liquid on right
          directionGL = twoPhaseEulerAdvection->fluxCalculatorGasLiquid->GetFluxCalculatorFunction()(
              twoPhaseEulerAdvection->fluxCalculatorGasLiquid->GetFluxCalculatorContext(), normalVelocityL, aG_L, densityG_L, pL, normalVelocityR, aL_R, densityL_R, pR, &massFluxGL, &p12GL);
      } else if (alphaL < alphaR) {
          // liquid on left, gas on right
          directionGL = twoPhaseEulerAdvection->fluxCalculatorLiquidGas->GetFluxCalculatorFunction()(
              twoPhaseEulerAdvection->fluxCalculatorLiquidGas->GetFluxCalculatorContext(), normalVelocityL, aL_L, densityL_L, pL, normalVelocityR, aG_R, densityG_R, pR, &massFluxGL, &p12GL);
      }
    } */

 //Calculate total flux
PetscReal massFluxM = 0.0, p12M = 0.0;
fluxCalculator::Direction directionM = fluxCalculator::Direction::NA;
PetscReal density_L = densityG_L*alphaL + densityL_L*(1-alphaL);
PetscReal density_R = densityG_R*alphaR + densityL_R*(1-alphaR);
PetscReal a_L = (1/ (alphaL/aG_L + (1-alphaL)/aL_L) );
PetscReal a_R = (1/ (alphaR/aG_R + (1-alphaR)/aL_R) );

directionM = twoPhaseEulerAdvection->fluxCalculatorGasGas->GetFluxCalculatorFunction()(
twoPhaseEulerAdvection->fluxCalculatorGasGas->GetFluxCalculatorContext(), normalVelocityL, a_L, density_L, pL, normalVelocityR, a_R, density_R, pR, &massFluxM, &p12M);

//p12M=1e5;
//massFluxM=0;

    PetscReal velMagL = MagVector(dim, velocityL);
    PetscReal velMagR = MagVector(dim, velocityR);

PetscReal epsilon = 1e-8;
if((massFluxM*velMagL/p12M < epsilon) and (massFluxM*velMagR/p12M < epsilon)){
if (( PetscAbs(alphaR + alphaL)/2 > 0.1  ) and ( PetscAbs(alphaR + alphaL)/2 < 0.9  )){std::cout << "massFluxM  " << massFluxM<<"\n";}
massFluxM = 0;
}

//DMPlexCellGradFromCell(phitildeDM, vertex, phitildeLocalVec, -1, 0, gradphiv); 


//if (alphaR < 0.5001){ std::cout << "massfluxM " << massFluxM << "\n"; }

flux[CompressibleFlowFields::RHO] = massFluxM*areaMag;
flux[CompressibleFlowFields::RHOE] = 0.0;
for (PetscInt n = 0; n < dim; n++) { flux[CompressibleFlowFields::RHOU + n] = 0.0; }

    // Calculate total flux
//    flux[CompressibleFlowFields::RHO] = (massFluxGG * areaMag * alphaGG) + (massFluxGL * areaMag * alphaGL) + (massFluxLL * areaMag * alphaLL);
//    flux[CompressibleFlowFields::RHOE] = 0.0;
//    for (PetscInt n = 0; n < dim; n++) {
//        flux[CompressibleFlowFields::RHOU + n] = 0.0;
//    }


PetscReal internalEnergy_L = (1/ (alphaL/internalEnergyG_L + (1-alphaL)/internalEnergyL_L) );
PetscReal internalEnergy_R = (1/ (alphaR/internalEnergyG_R + (1-alphaR)/internalEnergyL_R) );
PetscReal H_L = internalEnergy_L + velMagL*velMagL/2 + p12M/density_L;
PetscReal H_R = internalEnergy_R + velMagR*velMagR/2 + p12M/density_R;

//PetscReal epsilon = 1e-3;
//PetscReal HG_L = internalEnergyG_L + velMagL * velMagL / 2.0 + p12GG / densityG_L;
//PetscReal HG_R = internalEnergyG_R + velMagR * velMagR / 2.0 + p12GG / densityG_R;
//H_L = (1/ (alphaGL/HG_L + (1-alphaGL)/HL_L) );
//H_R = (1/ (alphaGR/HG_R + (1-alphaGR)/HL_R) );
if (directionM == fluxCalculator::LEFT) {

      flux[CompressibleFlowFields::RHOE] += (H_L * massFluxM * areaMag);
          for (PetscInt n = 0; n < dim; n++) {
 PetscReal rhouunL = velocityL[n] * areaMag * (massFluxM);
PetscReal nxp = (p12M) * fg->normal[n];
//if (rhouunL/nxp < epsilon){rhouunL = 0;}
              flux[CompressibleFlowFields::RHOU + n] += rhouunL + nxp; //velocityL[n] * areaMag * (massFluxM) + (p12M) * fg->normal[n];
          }

} else if (directionM == fluxCalculator::RIGHT) {

          flux[CompressibleFlowFields::RHOE] += (H_R * massFluxM * areaMag);
          for (PetscInt n = 0; n < dim; n++) {
PetscReal rhouunR = velocityR[n] * areaMag * (massFluxM);
PetscReal nxp = (p12M) * fg->normal[n];
//if (rhouunR/nxp < epsilon){rhouunR = 0;}

              flux[CompressibleFlowFields::RHOU + n] += rhouunR + nxp;// velocityR[n] * areaMag * (massFluxM) + (p12M) * fg->normal[n];
          }

} else {
          flux[CompressibleFlowFields::RHOE] += (0.5 * (H_L + H_R) * massFluxM * areaMag);
for (PetscInt n = 0; n < dim; n++) {
 PetscReal rhouun = 0.5 * (velocityL[n] + velocityR[n]) * areaMag * (massFluxM);
PetscReal nxp = (p12M) * fg->normal[n];
//if (rhouun/nxp < epsilon){rhouun = 0;}*/

     flux[CompressibleFlowFields::RHOU + n] += rhouun + nxp; // 0.5 * (velocityL[n] + velocityR[n]) * areaMag * (massFluxM) + (p12M) * fg->normal[n];
}

}

    // gas interface
//    if (alphaGG > PETSC_SMALL) {
//      if (directionGG == fluxCalculator::LEFT) {  // direction of GG,LL,LG should match since uniform velocity??
//        PetscReal HG_L = internalEnergyG_L + velMagL * velMagL / 2.0 + p12GG / densityG_L;
//      flux[CompressibleFlowFields::RHOE] += (HG_L * massFluxGG * areaMag * alphaGG);
//
//          for (PetscInt n = 0; n < dim; n++) {
//              flux[CompressibleFlowFields::RHOU + n] += velocityL[n] * areaMag * (massFluxGG * alphaGG) + (p12GG * alphaGG) * fg->normal[n];
//          }
//      } else if (directionGG == fluxCalculator::RIGHT) {
//          PetscReal HG_R = internalEnergyG_R + velMagR * velMagR / 2.0 + p12GG / densityG_R;
//          flux[CompressibleFlowFields::RHOE] += (HG_R * massFluxGG * areaMag * alphaGG);
//
//          for (PetscInt n = 0; n < dim; n++) {
//              flux[CompressibleFlowFields::RHOU + n] += velocityR[n] * areaMag * (massFluxGG * alphaGG) + (p12GG * alphaGG) * fg->normal[n];
//          }
/*      } else {
          PetscReal HG_L = internalEnergyG_L + velMagL * velMagL / 2.0 + p12GG / densityG_L;
          PetscReal HG_R = internalEnergyG_R + velMagR * velMagR / 2.0 + p12GG / densityG_R;

          flux[CompressibleFlowFields::RHOE] += (0.5 * (HG_L + HG_R) * massFluxGG * areaMag * alphaGG);
          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += 0.5 * (velocityL[n] + velocityR[n]) * areaMag * (massFluxGG * alphaGG) + (p12GG * alphaGG) * fg->normal[n];
          }
      }
    } */

//if (PetscAbsReal(fg->centroid[0] + 0.0065)<PETSC_SMALL && PetscAbsReal(fg->centroid[1]+0.021)<PETSC_SMALL) printf("%.16e\t%.16e\n", massFluxLL, alphaLL);
//if (PetscAbsReal(fg->centroid[0] + 0.0065)<PETSC_SMALL && PetscAbsReal(fg->centroid[1]+0.02)<PETSC_SMALL) printf("%.16e\t%.16e\n", massFluxLL, alphaLL);

    // add liquid interface
/*    if (alphaLL > PETSC_SMALL) {
      if (directionLL == fluxCalculator::LEFT) {  // direction of GG,LL,LG should match since uniform velocity???
          PetscReal HL_L = internalEnergyL_L + velMagL * velMagL / 2.0 + p12LL / densityL_L;
          flux[CompressibleFlowFields::RHOE] += (HL_L * massFluxLL * areaMag * alphaLL);

          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += velocityL[n] * areaMag * (massFluxLL * alphaLL) + (p12LL * alphaLL) * fg->normal[n];
          }
      } else if (directionLL == fluxCalculator::RIGHT) {
          PetscReal HL_R = internalEnergyL_R + velMagR * velMagR / 2.0 + p12LL / densityL_R;
          flux[CompressibleFlowFields::RHOE] += (HL_R * massFluxLL * areaMag * alphaLL);

          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += velocityR[n] * areaMag * (massFluxLL * alphaLL) + (p12LL * alphaLL) * fg->normal[n];
          }
      } else {
          PetscReal HL_L = internalEnergyL_L + velMagL * velMagL / 2.0 + p12LL / densityL_L;
          PetscReal HL_R = internalEnergyL_R + velMagR * velMagR / 2.0 + p12LL / densityL_R;

          flux[CompressibleFlowFields::RHOE] += (0.5 * (HL_L + HL_R) * massFluxLL * areaMag * alphaLL);
          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += 0.5 * (velocityL[n] + velocityR[n]) * areaMag * (massFluxLL * alphaLL) + (p12LL * alphaLL) * fg->normal[n];
          }
      }
    }

    // add gas-liquid or liquid-gas interface
    if (alphaGL > PETSC_SMALL) {
      if (directionGL == fluxCalculator::LEFT) {  // direction of GG,LL,LG should match since uniform velocity???
          PetscReal HGL_L = 0.0;
          if (alphaL > alphaR) {
              // gas on left
              HGL_L = internalEnergyG_L + velMagL * velMagL / 2.0 + p12GL / densityG_L;
          } else if (alphaL < alphaR) {
              // liquid on left
              HGL_L = internalEnergyL_L + velMagL * velMagL / 2.0 + p12GL / densityL_L;
          } else {
              // no discontinuous region
              HGL_L = 0.0;
          }
          flux[CompressibleFlowFields::RHOE] += (HGL_L * massFluxGL * areaMag * alphaGL);

          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += velocityL[n] * areaMag * (massFluxGL * alphaGL) + (p12GL * alphaGL) * fg->normal[n];
          }
      } else if (directionGL == fluxCalculator::RIGHT) {
          PetscReal HGL_R = 0.0;
          if (alphaL > alphaR) {
              // liquid on right
              HGL_R = internalEnergyL_R + velMagR * velMagR / 2.0 + p12GL / densityL_R;
          } else if (alphaL < alphaR) {
              // gas on right
              HGL_R = internalEnergyG_R + velMagR * velMagR / 2.0 + p12GL / densityG_R;
          } else {
              // no discontinuous region
              HGL_R = 0.0;
          }
          flux[CompressibleFlowFields::RHOE] += (HGL_R * massFluxGL * areaMag * alphaGL);

          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += velocityR[n] * areaMag * (massFluxGL * alphaGL) + (p12GL * alphaGL) * fg->normal[n];
          }
      } else {
          PetscReal HGL_L = 0.0;
          if (alphaL > alphaR) {
              // gas on left
              HGL_L = internalEnergyG_L + velMagL * velMagL / 2.0 + p12GL / densityG_L;
          } else if (alphaL < alphaR) {
              // liquid on left
              HGL_L = internalEnergyL_L + velMagL * velMagL / 2.0 + p12GL / densityL_L;
          } else {
              // no discontinuous region
              HGL_L = 0.0;
          }
          PetscReal HGL_R = 0.0;
          if (alphaL > alphaR) {
              // liquid on right
              HGL_R = internalEnergyL_R + velMagR * velMagR / 2.0 + p12GL / densityL_R;
          } else if (alphaL < alphaR) {
              // gas on right
              HGL_R = internalEnergyG_R + velMagR * velMagR / 2.0 + p12GL / densityG_R;
          } else {
              // no discontinuous region
              HGL_R = 0.0;
          }

          flux[CompressibleFlowFields::RHOE] += (0.5 * (HGL_L + HGL_R) * massFluxGL * areaMag * alphaGL);
          for (PetscInt n = 0; n < dim; n++) {
              flux[CompressibleFlowFields::RHOU + n] += 0.5 * (velocityL[n] + velocityR[n]) * areaMag * (massFluxGL * alphaGL) + (p12GL * alphaGL) * fg->normal[n];
          }
      }
    } */


    PetscFunctionReturn(0);
}
PetscErrorCode ablate::finiteVolume::processes::TwoPhaseEulerAdvection::CompressibleFlowComputeVFFlux(PetscInt dim, const PetscFVFaceGeom *fg, const PetscInt *uOff, const PetscScalar *fieldL,
                                                                                                      const PetscScalar *fieldR, const PetscInt *aOff, const PetscScalar *auxL, const PetscScalar *auxR,
                                                                                                      PetscScalar *flux, void *ctx) {
    PetscFunctionBeginUser;
    auto twoPhaseEulerAdvection = (TwoPhaseEulerAdvection *)ctx;

    // Compute the norm
    PetscReal norm[3];
    NormVector(dim, fg->normal, norm);
    const PetscReal areaMag = MagVector(dim, fg->normal);

    //     Decode left and right states
    PetscReal densityL;
    PetscReal densityG_L;
    PetscReal densityL_L;
    PetscReal normalVelocityL;  // uniform velocity in cell
    PetscReal velocityL[3];
    PetscReal internalEnergyL;
    PetscReal internalEnergyG_L;
    PetscReal internalEnergyL_L;
    PetscReal aG_L;
    PetscReal aL_L;
    PetscReal MG_L;
    PetscReal ML_L;
    PetscReal pL;  // pressure equilibrium
    PetscReal tL;
    PetscReal alphaL;
    twoPhaseEulerAdvection->decoder->DecodeTwoPhaseEulerState(dim,
                                                              uOff,
                                                              fieldL,
                                                              norm,
                                                              &densityL,
                                                              &densityG_L,
                                                              &densityL_L,
                                                              &normalVelocityL,
                                                              velocityL,
                                                              &internalEnergyL,
                                                              &internalEnergyG_L,
                                                              &internalEnergyL_L,
                                                              &aG_L,
                                                              &aL_L,
                                                              &MG_L,
                                                              &ML_L,
                                                              &pL,
                                                              &tL,
                                                              &alphaL);

    PetscReal densityR;
    PetscReal densityG_R;
    PetscReal densityL_R;
    PetscReal normalVelocityR;
    PetscReal velocityR[3];
    PetscReal internalEnergyR;
    PetscReal internalEnergyG_R;
    PetscReal internalEnergyL_R;
    PetscReal aG_R;
    PetscReal aL_R;
    PetscReal MG_R;
    PetscReal ML_R;
    PetscReal pR;
    PetscReal tR;
    PetscReal alphaR;
    twoPhaseEulerAdvection->decoder->DecodeTwoPhaseEulerState(dim,
                                                              uOff,
                                                              fieldR,
                                                              norm,
                                                              &densityR,
                                                              &densityG_R,
                                                              &densityL_R,
                                                              &normalVelocityR,
                                                              velocityR,
                                                              &internalEnergyR,
                                                              &internalEnergyG_R,
                                                              &internalEnergyL_R,
                                                              &aG_R,
                                                              &aL_R,
                                                              &MG_R,
                                                              &ML_R,
                                                              &pR,
                                                              &tR,
                                                              &alphaR);



    // get the face values
    PetscReal massFlux;
    PetscReal p12;

    // calculate gas sub-area of face (stratified flow model)
    fluxCalculator::Direction directionG = twoPhaseEulerAdvection->fluxCalculatorGasGas->GetFluxCalculatorFunction()(
        twoPhaseEulerAdvection->fluxCalculatorGasGas->GetFluxCalculatorContext(), normalVelocityL, aG_L, densityG_L, pL, normalVelocityR, aG_R, densityG_R, pR, &massFlux, &p12);


    PetscReal velMagL = MagVector(dim, velocityL);
    PetscReal velMagR = MagVector(dim, velocityR);
PetscReal epsilon = 1e-5;
if((massFlux*velMagL/p12 < epsilon) and (massFlux*velMagR/p12 < epsilon)){ massFlux = 0;}

    if (directionG == fluxCalculator::LEFT) {
        flux[0] = massFlux * areaMag * alphaL;
    } else if (directionG == fluxCalculator::RIGHT) {
        flux[0] = massFlux * areaMag * alphaR;
    } else {
        flux[0] = massFlux * areaMag * 0.5 * (alphaL + alphaR);
    }

    PetscFunctionReturn(0);
}

std::shared_ptr<ablate::finiteVolume::processes::TwoPhaseEulerAdvection::TwoPhaseDecoder> ablate::finiteVolume::processes::TwoPhaseEulerAdvection::CreateTwoPhaseDecoder(
    PetscInt dim, const std::shared_ptr<eos::EOS> &eosGas, const std::shared_ptr<eos::EOS> &eosLiquid) {
    // check if both perfect gases, use analytical solution
    auto perfectGasEos1 = std::dynamic_pointer_cast<eos::PerfectGas>(eosGas);
    auto perfectGasEos2 = std::dynamic_pointer_cast<eos::PerfectGas>(eosLiquid);
    // check if stiffened gas
    auto stiffenedGasEos1 = std::dynamic_pointer_cast<eos::StiffenedGas>(eosGas);
    auto stiffenedGasEos2 = std::dynamic_pointer_cast<eos::StiffenedGas>(eosLiquid);

    if (perfectGasEos1 && perfectGasEos2) {
        return std::make_shared<PerfectGasPerfectGasDecoder>(dim, perfectGasEos1, perfectGasEos2);
    } else if (perfectGasEos1 && stiffenedGasEos2) {
        return std::make_shared<PerfectGasStiffenedGasDecoder>(dim, perfectGasEos1, stiffenedGasEos2);
    } else if (perfectGasEos2 && stiffenedGasEos1) {
        return std::make_shared<PerfectGasStiffenedGasDecoder>(dim, perfectGasEos2, stiffenedGasEos1);
    } else if (stiffenedGasEos1 && stiffenedGasEos2) {
        return std::make_shared<StiffenedGasStiffenedGasDecoder>(dim, stiffenedGasEos1, stiffenedGasEos2);
    }
    throw std::invalid_argument("Unknown combination of equation of states for ablate::finiteVolume::processes::TwoPhaseEulerAdvection::TwoPhaseDecoder");
}

/**PerfectGasPerfectGasDecoder**************/
ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasPerfectGasDecoder::PerfectGasPerfectGasDecoder(PetscInt dim, const std::shared_ptr<eos::PerfectGas> &eosGas,
                                                                                                                  const std::shared_ptr<eos::PerfectGas> &eosLiquid)
    : eosGas(eosGas), eosLiquid(eosLiquid) {
    // Create the fake euler field
    auto fakeEulerField = ablate::domain::Field{.name = CompressibleFlowFields::EULER_FIELD,
                                                .numberComponents = 2 + dim,
                                                .components = {},
                                                .id = PETSC_DEFAULT,
                                                .subId = PETSC_DEFAULT,
                                                .offset = 0,
                                                .location = ablate::domain::FieldLocation::SOL,
                                                .type = ablate::domain::FieldType::FVM,
                                                .tags = {}};

    // size up the scratch vars
    gasEulerFieldScratch.resize(2 + dim);
    liquidEulerFieldScratch.resize(2 + dim);

    // extract/store compute calls
    gasComputeTemperature = eosGas->GetThermodynamicFunction(eos::ThermodynamicProperty::Temperature, {fakeEulerField});
    gasComputeInternalEnergy = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::InternalSensibleEnergy, {fakeEulerField});
    gasComputeSpeedOfSound = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::SpeedOfSound, {fakeEulerField});
    gasComputePressure = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::Pressure, {fakeEulerField});

    liquidComputeTemperature = eosLiquid->GetThermodynamicFunction(eos::ThermodynamicProperty::Temperature, {fakeEulerField});
    liquidComputeInternalEnergy = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::InternalSensibleEnergy, {fakeEulerField});
    liquidComputeSpeedOfSound = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::SpeedOfSound, {fakeEulerField});
    liquidComputePressure = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::Pressure, {fakeEulerField});
}

void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasPerfectGasDecoder::DecodeTwoPhaseEulerState(PetscInt dim, const PetscInt *uOff, const PetscReal *conservedValues,
                                                                                                                    const PetscReal *normal, PetscReal *density, PetscReal *densityG,
                                                                                                                    PetscReal *densityL, PetscReal *normalVelocity, PetscReal *velocity,
                                                                                                                    PetscReal *internalEnergy, PetscReal *internalEnergyG, PetscReal *internalEnergyL,
                                                                                                                    PetscReal *aG, PetscReal *aL, PetscReal *MG, PetscReal *ML, PetscReal *p,
                                                                                                                    PetscReal *T, PetscReal *alpha) {


    // (RHO, RHOE, RHOU, RHOV, RHOW)
    const int EULER_FIELD = 2;
    const int VF_FIELD = 1;

    // decode
    *density = conservedValues[CompressibleFlowFields::RHO + uOff[EULER_FIELD]];

    if (*density < PETSC_SMALL) { // This occurs when a cell hasn't been initialized yet. Usually FVM boundary cells
        *densityG = 0.0;
        *densityL = 0.0;
        *internalEnergyG = 0.0;
        *internalEnergyL = 0.0;
        *alpha = 0.0;
        *p = 0.0;
        *aG = 0.0;
        *aL = 0.0;
        *MG = 0.0;
        *ML = 0.0;

        return;
    }


    PetscReal totalEnergy = conservedValues[CompressibleFlowFields::RHOE + uOff[EULER_FIELD]] / (*density);
    PetscReal densityVF = conservedValues[uOff[VF_FIELD]];

    // Get the velocity in this direction, and kinetic energy
    (*normalVelocity) = 0.0;
    PetscReal ke = 0.0;
    for (PetscInt d = 0; d < dim; d++) {
        velocity[d] = conservedValues[CompressibleFlowFields::RHOU + d + uOff[EULER_FIELD]] / (*density);
        (*normalVelocity) += velocity[d] * normal[d];
        ke += PetscSqr(velocity[d]);
    }
    ke *= 0.5;
    (*internalEnergy) = (totalEnergy)-ke;

    // mass fractions
    PetscReal Yg = densityVF / (*density);
    PetscReal Yl = ((*density) - densityVF) / (*density);

    PetscReal R1 = eosGas->GetGasConstant();
    PetscReal R2 = eosLiquid->GetGasConstant();
    PetscReal gamma1 = eosGas->GetSpecificHeatRatio();
    PetscReal gamma2 = eosLiquid->GetSpecificHeatRatio();
    PetscReal cv1 = R1 / (gamma1 - 1);
    PetscReal cv2 = R2 / (gamma2 - 1);

    PetscReal eG = (*internalEnergy) / (Yg + Yl * cv2 / cv1);
    PetscReal etG = eG + ke;
    PetscReal eL = cv2 / cv1 * eG;

    PetscReal etL = eL + ke;
    PetscReal rhoG = (*density) * (Yg + Yl * eL / eG * (gamma2 - 1) / (gamma1 - 1));
    PetscReal rhoL = rhoG * eG / eL * (gamma1 - 1) / (gamma2 - 1);

    PetscReal pG = 0;
    PetscReal pL;
    PetscReal a1 = 0;
    PetscReal a2 = 0;

    // Fill the scratch array for gas
    liquidEulerFieldScratch[CompressibleFlowFields::RHO] = rhoL;
    liquidEulerFieldScratch[CompressibleFlowFields::RHOE] = rhoL * etL;
    for (PetscInt d = 0; d < dim; d++) {
        liquidEulerFieldScratch[CompressibleFlowFields::RHOU + d] = velocity[d] * rhoL;
    }

    // Decode the gas
    {
        liquidComputeTemperature.function(liquidEulerFieldScratch.data(), T, liquidComputeTemperature.context.get()) >> utilities::PetscUtilities::checkError;
        liquidComputeInternalEnergy.function(liquidEulerFieldScratch.data(), *T, &eL, liquidComputeInternalEnergy.context.get()) >> utilities::PetscUtilities::checkError;
        liquidComputeSpeedOfSound.function(liquidEulerFieldScratch.data(), *T, &a2, liquidComputeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;
        liquidComputePressure.function(liquidEulerFieldScratch.data(), *T, &pL, liquidComputePressure.context.get()) >> utilities::PetscUtilities::checkError;
    }

    // Fill the scratch array for gas
    gasEulerFieldScratch[CompressibleFlowFields::RHO] = rhoG;
    gasEulerFieldScratch[CompressibleFlowFields::RHOE] = rhoG * etG;
    for (PetscInt d = 0; d < dim; d++) {
        gasEulerFieldScratch[CompressibleFlowFields::RHOU + d] = velocity[d] * rhoG;
    }

    // Decode the gas
    {
        gasComputeTemperature.function(gasEulerFieldScratch.data(), T, gasComputeTemperature.context.get()) >> utilities::PetscUtilities::checkError;
        gasComputeInternalEnergy.function(gasEulerFieldScratch.data(), *T, &eG, gasComputeInternalEnergy.context.get()) >> utilities::PetscUtilities::checkError;
        gasComputeSpeedOfSound.function(gasEulerFieldScratch.data(), *T, &a1, gasComputeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;
        gasComputePressure.function(gasEulerFieldScratch.data(), *T, &pG, gasComputePressure.context.get()) >> utilities::PetscUtilities::checkError;
    }

    // once state defined
    *densityG = rhoG;
    *densityL = rhoL;
    *internalEnergyG = eG;
    *internalEnergyL = eL;
    *alpha = densityVF / (*densityG);
    *p = pG;  // pressure equilibrium, pG = pL
    *aG = a1;
    *aL = a2;
    *MG = (*normalVelocity) / (*aG);
    *ML = (*normalVelocity) / (*aL);
}

/**PerfectGasStiffenedGasDecoder**************/
ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasStiffenedGasDecoder::PerfectGasStiffenedGasDecoder(PetscInt dim, const std::shared_ptr<eos::PerfectGas> &eosGas,
                                                                                                                      const std::shared_ptr<eos::StiffenedGas> &eosLiquid)
    : eosGas(eosGas), eosLiquid(eosLiquid) {
    // Create the fake euler field
    auto fakeEulerField = ablate::domain::Field{.name = CompressibleFlowFields::EULER_FIELD,
                                                .numberComponents = 2 + dim,
                                                .components = {},
                                                .id = PETSC_DEFAULT,
                                                .subId = PETSC_DEFAULT,
                                                .offset = 0,
                                                .location = ablate::domain::FieldLocation::SOL,
                                                .type = ablate::domain::FieldType::FVM,
                                                .tags = {}};

    // size up the scratch vars
    gasEulerFieldScratch.resize(2 + dim);
    liquidEulerFieldScratch.resize(2 + dim);

    // extract/store compute calls
    gasComputeTemperature = eosGas->GetThermodynamicFunction(eos::ThermodynamicProperty::Temperature, {fakeEulerField});
    gasComputeInternalEnergy = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::InternalSensibleEnergy, {fakeEulerField});
    gasComputeSpeedOfSound = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::SpeedOfSound, {fakeEulerField});
    gasComputePressure = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::Pressure, {fakeEulerField});

    liquidComputeTemperature = eosLiquid->GetThermodynamicFunction(eos::ThermodynamicProperty::Temperature, {fakeEulerField});
    liquidComputeInternalEnergy = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::InternalSensibleEnergy, {fakeEulerField});
    liquidComputeSpeedOfSound = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::SpeedOfSound, {fakeEulerField});
    liquidComputePressure = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::Pressure, {fakeEulerField});
}

#include <signal.h>

/* void SolveQuadratic(const PetscReal a, const PetscReal b, const PetscReal c, PetscReal *x1, PetscReal *x2) {
  if (PetscAbsReal(a) < PETSC_SMALL) {
    *x1 = *x2 = -c/b;
  }
  else if (PetscAbsReal(c) < PETSC_SMALL) {
    *x1 = 0.0;
    *x2 = -b/a;
  }
  else {

    PetscReal disc = PetscSqrtReal(PetscSqr(b) - 4.0*a*c);
    if (b > 0) {
      *x1 = 0.5*(-b - disc)/a;
      *x2 = 2.0*c/(-b - disc);
    }
    else {
      *x1 = 2.0*c/(-b + disc);
      *x2 = 0.5*(-b + disc)/a;
    }


//printf("%+.16e\t%+.16e\t%+.16e\t%+.16e\t%+.16e\t", a, b, c, *x1, *x2);

// *x1 = (-b + PetscSqrtReal(PetscSqr(b) - 4 * a * c)) / (2 * a);
// *x2 = (-b - PetscSqrtReal(PetscSqr(b) - 4 * a * c)) / (2 * a);
//printf("%+.16e\t%.16e\n", *x1, *x2);


//    *x1 = -0.5*(b + PetscSignReal(b)*PetscSqrtReal(PetscSqr(b) - 4.0*a*c))/a;
//    *x2 = c/(a*(*x1));
//      *x1 = (-b + PetscSqrtReal(PetscSqr(b) - 4 * a * c)) / (2 * a);
//      *x2 = (-b - PetscSqrtReal(PetscSqr(b) - 4 * a * c)) / (2 * a);
  }
}

*/

#include <quadmath.h>
void SolveQuadratic(const __float128 a, const __float128 b, const __float128 c, __float128 *x1, __float128 *x2) {
  if (fabsq(a) < PETSC_SMALL) {
    *x1 = *x2 = -c/b;
  }
  else if (fabsq(c) < PETSC_SMALL) {
    *x1 = 0.0;
    *x2 = -b/a;
  }
  else {
    __float128 disc = sqrtq(b*b - 4.0*a*c);
    if (b > 0) {
      *x1 = 0.5*(-b - disc)/a;
      *x2 = 2.0*c/(-b - disc);
    }
    else {
      *x1 = 2.0*c/(-b + disc);
      *x2 = 0.5*(-b + disc)/a;
    }


  }
}
void SolveQuadratic(const PetscReal a, const PetscReal b, const PetscReal c, PetscReal *x1, PetscReal *x2) {
  if (PetscAbsReal(a) < PETSC_SMALL) {
    *x1 = *x2 = -c/b;
  }
  else if (PetscAbsReal(c) < PETSC_SMALL) {
    *x1 = 0.0;
    *x2 = -b/a;
  }
  else {
    PetscReal disc = PetscSqrtReal(b*b - 4.0*a*c);
    if (b > 0) {
      *x1 = 0.5*(-b - disc)/a;
      *x2 = 2.0*c/(-b - disc);
    }
    else {
      *x1 = 2.0*c/(-b + disc);
      *x2 = 0.5*(-b + disc)/a;
    }


  }
}

/*

void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasStiffenedGasDecoder::MixedDecodeQuadratic(const PetscReal density, const PetscReal internalEnergy, const PetscReal Yg, const PetscReal Yl, PetscReal *rhoG_out, PetscReal *rhoL_out, PetscReal *eG_out, PetscReal *eL_out) {

    const PetscReal RG = eosGas->GetGasConstant();
    const PetscReal cpL = eosLiquid->GetSpecificHeatCp();
    const PetscReal p0L = eosLiquid->GetReferencePressure();
    const PetscReal gammaG = eosGas->GetSpecificHeatRatio();
    const PetscReal gammaL = eosLiquid->GetSpecificHeatRatio();
    const PetscReal cvG = RG / (gammaG - 1);

    const PetscReal A = cpL / cvG / gammaL;
    const PetscReal B = Yg + Yl * A;
    const PetscReal D = p0L / (density) - internalEnergy;
    const PetscReal E = Yg * p0L / (density) + Yl * A * internalEnergy;
    PetscReal a, b, c, root1, root2, eG, eL, rhoG, rhoL;

    if (Yg < 0.5) {  // avoid divide by zero, 1E-3
        a = B * (Yg * (gammaL - 1) - Yg * (gammaG - 1) - gammaL * B);
        b = internalEnergy * Yg * (gammaG - 1) + internalEnergy * B + Yg * (gammaL - 1) * D - gammaL * D * B;
        c = internalEnergy * D;
        SolveQuadratic(a, b, c, &root1, &root2);
        if (root1 > PETSC_SMALL && root2 > PETSC_SMALL) {
            eG = PetscMax(root1, root2);  // used to be Min
        } else {
            eG = PetscMax(root1, root2);  // take positive root
        }

        eL = (internalEnergy - Yg * eG) / Yl;
    } else {  // else if Yl<10e-5,
        a = B * Yl * (Yg * (gammaL - 1) - gammaL * B - Yg * (gammaG - 1));
        b = Yg * (gammaG - 1) * B * internalEnergy + Yg * (gammaG - 1) * Yl * A * internalEnergy - Yg * (gammaL - 1) * E + gammaL * E * B + gammaL * Yl * B * A * internalEnergy;
        c = (-A) * internalEnergy * (Yg * (gammaG - 1) * internalEnergy + gammaL * E);
        SolveQuadratic(a, b, c, &root1, &root2);
        if (root1 > PETSC_SMALL && root2 > PETSC_SMALL) {
            eL = PetscMin(root1, root2);
        } else {
            eL = PetscMax(root1, root2);  // take positive root
        }

        eG = (internalEnergy - Yl * eL) / Yg;
    }

    a = (gammaG - 1) * eG;
    b = gammaL * p0L - Yg * density * eG * (gammaG - 1) - Yl * density * eL * (gammaL - 1);
    c = -Yg * density * gammaL * p0L;
    SolveQuadratic(a, b, c, &root1, &root2);
    rhoG = PetscMax(root1, root2);
    rhoL = ((gammaG - 1) * eG * rhoG + gammaL * p0L) / (gammaL - 1) / eL;


    // Check to make sure all of the results are physical
    if (eG < 0) {                 // negative internal energy not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative internal energy eG");
    }
    if (eL < 0) {
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative internal energy eL");
    }

    if (rhoG < 0) {  // negative density not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative density rhoG");
    }
    if (rhoL < 0) {  // negative density not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative density rhoL");
    }

    // Check all of the equations
    if (PetscAbsReal(Yg/rhoG + Yl/rhoL - 1.0/density) > 1e-6) throw std::runtime_error("Density balance in decode is violated.\n");
    if (PetscAbsReal(Yg*eG + Yl*eL - internalEnergy) > 1e-6) throw std::runtime_error("Energy balance in decode is violated.\n");
    if (PetscAbsReal((gammaL - 1.0)*rhoL*eL - gammaL*p0L - (gammaG - 1.0)*rhoG*eG) > 1e-6) throw std::runtime_error("Pressure balance in decode is violated.\n");
    if (PetscAbsReal((eL - p0L/rhoL)*cvG*gammaL/cpL - eG) > 1e-6) throw std::runtime_error("Temperature balance in decode is violated.\n");

    *rhoG_out = rhoG;
    *rhoL_out = rhoL;
    *eG_out = eG;
    *eL_out = eL;
}

void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasStiffenedGasDecoder::MixedDecodeIncompressible(const PetscReal density, const PetscReal internalEnergy, const PetscReal Yg, const PetscReal Yl, PetscReal *rhoG_out, PetscReal *rhoL_out, PetscReal *eG_out, PetscReal *eL_out) {


    const PetscReal RG = eosGas->GetGasConstant();
    const PetscReal cpL = eosLiquid->GetSpecificHeatCp();
    const PetscReal p0L = eosLiquid->GetReferencePressure();
    const PetscReal gammaG = eosGas->GetSpecificHeatRatio();
    const PetscReal gammaL = eosLiquid->GetSpecificHeatRatio();
    const PetscReal cvG = RG / (gammaG - 1);

    PetscReal rhoL = 998.23, rhoG = 1.1614401858304297;

//    if (Yg > 1e-6) {
      rhoG = (density*rhoL*Yg)/(rhoL - density*Yl);
//    }

    PetscReal eL, eG;

    if (Yg > Yl) {
      eL = (cpL*internalEnergy*rhoL + cvG*gammaL*p0L*Yg)/(cvG*gammaL*rhoL*Yg + cpL*rhoL*Yl);
      eG = (internalEnergy - Yl*eL)/Yg;
    }
    else {
      eG = (cvG*internalEnergy*gammaL*rhoL - cvG*gammaL*p0L*Yl)/(cvG*gammaL*rhoL*Yg + cpL*rhoL*Yl);
      eL = (internalEnergy - Yg*eG)/Yl;
    }

    // Check to make sure all of the results are physical
    if (eG < 0) {                 // negative internal energy not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative internal energy eG");
    }
    if (eL < 0) {
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative internal energy eL");
    }

    if (rhoG < 0) {  // negative density not physical
      printf("%+f\t%+f\n", rhoG, rhoL);
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative density rhoG");
    }
    if (rhoL < 0) {  // negative density not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative density rhoL");
    }

    // Check all of the equations
    if (PetscAbsReal(Yg/rhoG + Yl/rhoL - 1.0/density) > 1e-6) throw std::runtime_error("Density balance in decode is violated.\n");
    if (PetscAbsReal(Yg*eG + Yl*eL - internalEnergy) > 1e-6) throw std::runtime_error("Energy balance in decode is violated.\n");
//    if (PetscAbsReal((gammaL - 1.0)*rhoL*eL - gammaL*p0L - (gammaG - 1.0)*rhoG*eG) > 1e-6) throw std::runtime_error("Pressure balance in decode is violated.\n");
    if (PetscAbsReal((eL - p0L/rhoL)*cvG*gammaL/cpL - eG) > 1e-6) throw std::runtime_error("Temperature balance in decode is violated.\n");

    *rhoG_out = rhoG;
    *rhoL_out = rhoL;
    *eG_out = eG;
    *eL_out = eL;
}*/


/*
void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasStiffenedGasDecoder::MixedDecodeSNES(const PetscReal density, const PetscReal internalEnergy, const PetscReal Yg, const PetscReal Yl, PetscReal *rhoG_out, PetscReal *rhoL_out, PetscReal *eG_out, PetscReal *eL_out) {

    const PetscReal RG = eosGas->GetGasConstant();
    const PetscReal cpL = eosLiquid->GetSpecificHeatCp();
    const PetscReal p0L = eosLiquid->GetReferencePressure();
    const PetscReal gammaG = eosGas->GetSpecificHeatRatio();
    const PetscReal gammaL = eosLiquid->GetSpecificHeatRatio();
    const PetscReal cvG = RG / (gammaG - 1);


{
PetscReal e = internalEnergy;
PetscReal rho = density;
PetscReal A = -(gammaL*rho*(cvG*gammaG*Yg + cpL*Yl)*(cvG*gammaL*Yg + cpL*Yl));
PetscReal B = gammaL*(cvG*gammaL*(-p0L + e*(1 + gammaG)*rho)*Yg + cpL*(-(gammaL*p0L) + e*rho + e*gammaL*rho)*Yl);
PetscReal C = e*gammaL*gammaL*(p0L - e*rho);

PetscReal x1, x2;
SolveQuadratic(A, B, C, &x1, &x2);
PetscReal T = PetscMax(x1, x2);
PetscReal rhoL = gammaL*p0L*Yl/(e*gammaL - cvG*gammaL*T*Yg - cpL*T*Yl);
PetscReal rhoG = rho*rhoL*Yg/(rhoL - rho*Yl);

PetscReal pG, pL;
gasComputePressure.function(gasEulerFieldScratch.data(), T, &pG, gasComputePressure.context.get()) >> utilities::PetscUtilities::checkError;
liquidComputePressure.function(liquidEulerFieldScratch.data(), T, &pL, liquidComputePressure.context.get()) >> utilities::PetscUtilities::checkError;

printf("%+e\t%+e\t%+e\n", T, rhoG, rhoL);
NOTE0EXIT("%+e\t%+e\t%+e\t%+e\t%+e\n", T-300, rhoG-1.1614401858304297, rhoL-998.23, pG-1e5, pL-1e5);
}

    DecodeDataStructGas decodeDataStruct{
        .internalEnergy = internalEnergy,
        .density = density,
        .Yg = Yg,
        .Yl = Yl,
        .gamG = gammaG,
        .gamL = gammaL,
        .cvG = cvG,
        .cpL = cpL,
        .p0L = p0L,
    };

SNES snes;
Vec x, r;
Mat J;
VecCreate(PETSC_COMM_SELF, &x) >> utilities::PetscUtilities::checkError;
VecSetSizes(x, PETSC_DECIDE, 3) >> utilities::PetscUtilities::checkError;
VecSetFromOptions(x) >> utilities::PetscUtilities::checkError;

// Set the initial guess to the conserved energy and the internal energy
PetscScalar *ax;
VecGetArray(x, &ax) >> utilities::PetscUtilities::checkError;
ax[0] = 1.1614401858304297; // rho G
ax[1] = 998.23; // rho L
ax[2] = 300; // T

VecRestoreArray(x, &ax) >> utilities::PetscUtilities::checkError;


VecDuplicate(x, &r) >> utilities::PetscUtilities::checkError;

MatCreate(PETSC_COMM_SELF, &J) >> utilities::PetscUtilities::checkError;
MatSetSizes(J, 3, 3, 3, 3) >> utilities::PetscUtilities::checkError;
MatSetType(J, MATDENSE) >> utilities::PetscUtilities::checkError; // The KSP fails is this isn't a dense matrix
MatSetFromOptions(J) >> utilities::PetscUtilities::checkError;
MatSetUp(J) >> utilities::PetscUtilities::checkError;

SNESCreate(PETSC_COMM_SELF, &snes) >> utilities::PetscUtilities::checkError;
SNESSetOptionsPrefix(snes, "gasSolver_");
SNESSetFunction(snes, r, FormFunctionGas, &decodeDataStruct) >> utilities::PetscUtilities::checkError;
SNESSetJacobian(snes, J, J, FormJacobianGas, &decodeDataStruct) >> utilities::PetscUtilities::checkError;
SNESSetTolerances(snes, 1E-14, 1E-10, 1E-10, 1000, 10000) >> utilities::PetscUtilities::checkError;  // refine relative tolerance for more accurate pressure value
SNESSetFromOptions(snes) >> utilities::PetscUtilities::checkError;
SNESSolve(snes, NULL, x) >> utilities::PetscUtilities::checkError;

SNESConvergedReason reason;
SNESGetConvergedReason(snes, &reason) >> utilities::PetscUtilities::checkError;

if (reason < 0 || reason == SNES_CONVERGED_ITS) {
  throw std::runtime_error("SNES for stiffened gas-stiffened gas decode failed.\n");
}

VecGetArray(x, &ax) >> utilities::PetscUtilities::checkError;

NOTE0EXIT("%+e\t%+e\t%+e\n", ax[0], ax[1], ax[2]);

PetscReal rhoG = ax[0];
PetscReal rhoL = ax[1];
PetscReal eG   = ax[2];
PetscReal eL   = ax[3];
VecRestoreArray(x, &ax) >> utilities::PetscUtilities::checkError;

SNESDestroy(&snes) >> utilities::PetscUtilities::checkError;
VecDestroy(&x) >> utilities::PetscUtilities::checkError;
VecDestroy(&r) >> utilities::PetscUtilities::checkError;
MatDestroy(&J) >> utilities::PetscUtilities::checkError;



    // Check to make sure all of the results are physical
    if (eG < 0) {                 // negative internal energy not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative internal energy eG");
    }
    if (eL < 0) {
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative internal energy eL");
    }

    if (rhoG < 0) {  // negative density not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative density rhoG");
    }
    if (rhoL < 0) {  // negative density not physical
        throw std::invalid_argument("ablate::finiteVolume::twoPhaseEulerAdvection PerfectGas/StiffenedGas DecodeState cannot result in negative density rhoL");
    }

    // Check all of the equations
    if (PetscAbsReal(Yg/rhoG + Yl/rhoL - 1.0/density) > 1e-6) throw std::runtime_error("Density balance in decode is violated.\n");
    if (PetscAbsReal(Yg*eG + Yl*eL - internalEnergy) > 1e-6) throw std::runtime_error("Energy balance in decode is violated.\n");
    if (PetscAbsReal((gammaL - 1.0)*rhoL*eL - gammaL*p0L - (gammaG - 1.0)*rhoG*eG) > 1e-6) throw std::runtime_error("Pressure balance in decode is violated.\n");
    if (PetscAbsReal((eL - p0L/rhoL)*cvG*gammaL/cpL - eG) > 1e-6) throw std::runtime_error("Temperature balance in decode is violated.\n");

    *rhoG_out = rhoG;
    *rhoL_out = rhoL;
    *eG_out = eG;
    *eL_out = eL;
} */

/*
void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasStiffenedGasDecoder::DecodeTwoPhaseEulerState(PetscInt dim, const PetscInt *uOff, const PetscReal *conservedValues,
                                                                                                                      const PetscReal *normal, PetscReal *densityOut, PetscReal *densityG,
                                                                                                                      PetscReal *densityL, PetscReal *normalVelocityOut, PetscReal *velocityOut,
                                                                                                                      PetscReal *internalEnergyOut, PetscReal *internalEnergyG, PetscReal *internalEnergyL,
                                                                                                                      PetscReal *aG, PetscReal *aL, PetscReal *MG, PetscReal *ML, PetscReal *p,
                                                                                                                      PetscReal *T, PetscReal *alpha) {

    const int EULER_FIELD = 2;
    const int VF_FIELD = 1;


    __float128 density = conservedValues[CompressibleFlowFields::RHO + uOff[EULER_FIELD]];
    __float128 totalEnergy = conservedValues[CompressibleFlowFields::RHOE + uOff[EULER_FIELD]] / (density);
    __float128 densityVF = conservedValues[uOff[VF_FIELD]];

    *densityOut = *densityG = *densityL = NAN;
    *internalEnergyOut = *internalEnergyG = *internalEnergyL = NAN;
    *alpha = NAN;
    *p = NAN;
    *aG = *aL = NAN;
    *MG = *ML = NAN;

    // Get the velocity in this direction, and kinetic energy
    __float128 normalVelocity = 0.0q;
    __float128 ke = 0.0q;
    __float128 velocity[3] = {0.0q, 0.0q, 0.0q};
    for (PetscInt d = 0; d < dim; d++) {
        velocity[d] = conservedValues[CompressibleFlowFields::RHOU + d + uOff[EULER_FIELD]] / density;
        normalVelocity += velocity[d] * normal[d];
        ke += velocity[d]*velocity[d];
    }
    ke *= 0.5;
    __float128 internalEnergy = totalEnergy - ke;

    if (density < PETSC_SMALL) { // This occurs when a cell hasn't been initialized yet. Usually FVM boundary cells
        *normalVelocityOut = 0.0;
        for (PetscInt d = 0; d < dim; ++d) velocityOut[d] = 0.0;
        *densityOut = 0.0;
        *densityG = 0.0;
        *densityL = 0.0;
        *internalEnergyOut = 0.0;
        *internalEnergyG = 0.0;
        *internalEnergyL = 0.0;
        *alpha = 0.0;
        *p = 0.0;
        *aG = 0.0;
        *aL = 0.0;
        *MG = 0.0;
        *ML = 0.0;

        return;
    }


    // mass fractions
    __float128 Yg = fminq(1.0, fmaxq(0.0, densityVF / density));
    __float128 Yl = 1.0 - Yg;

    __float128 rhoL = NAN, rhoG = NAN, eG = NAN, eL = NAN;
    __float128 TL = NAN, TG = NAN, pG = NAN, pL = NAN, alphaG = NAN;

    const __float128 RG = eosGas->GetGasConstant();
    const __float128 cpL = eosLiquid->GetSpecificHeatCp();
    const __float128 p0L = eosLiquid->GetReferencePressure();
    const __float128 gammaG = eosGas->GetSpecificHeatRatio();
    const __float128 gammaL = eosLiquid->GetSpecificHeatRatio();
    const __float128 cvG = RG / (gammaG - 1);
    const __float128 cvL = cpL/gammaL;

    if (Yg < 1e-14q) { // All liquid
      rhoL = density;
      TL = (internalEnergy*rhoL - p0L)/(cvL*rhoL);
      pL = (gammaL - 1.0)*cvL*rhoL*TL - p0L;

      TG = TL;
      pG = pL;

      rhoG = pG / (RG*TG);

      eL = internalEnergy;
      eG = cvG*TG;

      alphaG = 0.0;
    }
    else if (Yl < 1e-14q) { //All gas
      rhoG = density;
      TG = internalEnergy/cvG;
      pG = (gammaG - 1.0)*cvG*rhoG*TG;

      TL = TG;
      pL = pG;

      rhoL = (pL + p0L)/((gammaL-1)*cvL*TL);

      eL = cvL*TL + p0L/rhoL;
      eG = internalEnergy;

      alphaG = 1.0;
    }
    else {
      __float128 e = internalEnergy;
      __float128 rho = density;
      __float128 A = rho*(cvG*Yg + cvL*Yl)*(cvG*gammaG*Yg + cvL*gammaL*Yl);
      __float128 B = cvG*(p0L - e*(1.0q + gammaG)*rho)*Yg + cvL*(-(e*rho) + gammaL*(p0L - e*rho))*Yl;
      __float128 C = e*(e*rho - p0L);

      __float128 x1, x2;
      SolveQuadratic(A, B, C, &x1, &x2);

      TG = TL = fmaxq(x1, x2);

      // This doesn't seem to make a difference
      if (Yg > Yl) {
        rhoL = gammaL*p0L*Yl/(e*gammaL - cvG*gammaL*TG*Yg - cpL*TL*Yl);
        rhoG = rho*rhoL*Yg/(rhoL - rho*Yl);
      }
      else {
        rhoG = p0L*rho*Yg/(p0L - e*rho + cvG*rho*TG*Yg + cvL*rho*TG*Yl);
        rhoL = rho*rhoG*Yl/(rhoG - rho*Yg);
      }

      pL = (gammaL - 1.0q)*cvL*rhoL*TL - p0L;
      pG = (gammaG - 1.0q)*cvG*rhoG*TG;

      eL = cvL*TL + p0L/rhoL;
      eG = cvG*TG;

      alphaG = densityVF / rhoG;
    }



    *aL = (PetscReal)sqrtq((gammaL - 1.0q)*gammaL*cvL*TL);
    *aG = (PetscReal)sqrtq((gammaG - 1.0q)*gammaG*cvG*TG);

if (alphaG < 0.5001){
//std::cout << "alpha rho rhoL rhoG Yl Yg pL pG  " << alphaG << " " << density << " " << rhoL << " " << rhoG << " " << Yl << " " << Yg << " " << pL << " " << pG << "\n";
//printf("alpha rho rhoL rhoG Yl Yg pL pG  %Qf %Qf %Qf %Qf %Qf %Qf %Qf %Qf\n", 
 //      alphaG, density, rhoL, rhoG, Yl, Yg, pL, pG);
printf("alpha rho rhoL rhoG Yl Yg pL pG  %f %f %f %f %f %f %f %f\n", 
       (double)alphaG, (double)density, (double)rhoL, (double)rhoG, 
       (double)Yl, (double)Yg, (double)pL, (double)pG);
}

    if (TL < PETSC_SMALL || TG < PETSC_SMALL) {
      throw std::runtime_error("Decode is returning negative temperature.\n");
    }

    if (pL < PETSC_SMALL || pG < PETSC_SMALL) {
//      printf("%ld\n", cnt);
      throw std::runtime_error("Decode is returning negative pressure.\n");
    }

    if (eL < PETSC_SMALL || eG < PETSC_SMALL) {
      throw std::runtime_error("Decode is returning negative energy.\n");
    }

    if (fabsq(TL - TG) > 1e-3*fminq(TL, TG)) {
      throw std::runtime_error("Decode is not returning temperature equilibrium.\n");
    }

    if (fabsq(pL - pG) > 1e-3*fminq(pL, pG)) {
      throw std::runtime_error("Decode is not returning pressure equilibrium.\n");
    }

    // once state defined
    *alpha = (PetscReal)(fminq(1.0, fmaxq(0.0, alphaG)));
    for (PetscInt d = 0; d < dim; d++) velocityOut[d] = (PetscReal)velocity[d];
    *normalVelocityOut = (PetscReal)normalVelocity;
    *densityOut = (PetscReal)density;
    *internalEnergyOut = (PetscReal)internalEnergy;
    *densityG = (PetscReal)rhoG;
    *densityL = (PetscReal)rhoL;
    *internalEnergyG = (PetscReal)eG;
    *internalEnergyL = (PetscReal)eL;
    *T = (PetscReal)(0.5*(TG + TL));
    *p = (PetscReal)(0.5*(pG + pL));  // pressure equilibrium, pG = pL
    *MG = (PetscReal)(normalVelocity / sqrtq((gammaG - 1.0q)*gammaG*cvG*TG));
    *ML = (PetscReal)(normalVelocity / sqrtq((gammaL - 1.0q)*gammaL*cvL*TL));

}
*/

 void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::PerfectGasStiffenedGasDecoder::DecodeTwoPhaseEulerState(PetscInt dim, const PetscInt *uOff, const PetscReal *conservedValues,
                                                                                                                      const PetscReal *normal, PetscReal *density, PetscReal *densityG,
                                                                                                                      PetscReal *densityL, PetscReal *normalVelocity, PetscReal *velocity,
                                                                                                                      PetscReal *internalEnergy, PetscReal *internalEnergyG, PetscReal *internalEnergyL,
                                                                                                                      PetscReal *aG, PetscReal *aL, PetscReal *MG, PetscReal *ML, PetscReal *p,
                                                                                                                      PetscReal *T, PetscReal *alpha) {




    const int EULER_FIELD = 2;
    const int VF_FIELD = 1;

    // decode
    *density = conservedValues[CompressibleFlowFields::RHO + uOff[EULER_FIELD]];
    PetscReal totalEnergy = conservedValues[CompressibleFlowFields::RHOE + uOff[EULER_FIELD]] / (*density);
    PetscReal densityVF = conservedValues[uOff[VF_FIELD]];

    *densityG = *densityL = NAN;
    *internalEnergyG = *internalEnergyL = NAN;
    *alpha = NAN;
    *p = NAN;
    *aG = *aL = NAN;
    *MG = *ML = NAN;

    // Get the velocity in this direction, and kinetic energy
    (*normalVelocity) = 0.0;
    PetscReal ke = 0.0;
    for (PetscInt d = 0; d < dim; d++) {
        velocity[d] = conservedValues[CompressibleFlowFields::RHOU + d + uOff[EULER_FIELD]] / (*density);
        (*normalVelocity) += velocity[d] * normal[d];
        ke += PetscSqr(velocity[d]);
    }
    ke *= 0.5;
    (*internalEnergy) = (totalEnergy)-ke;

    if (*density < PETSC_SMALL) { // This occurs when a cell hasn't been initialized yet. Usually FVM boundary cells
        *densityG = 0.0;
        *densityL = 0.0;
        *internalEnergyG = 0.0;
        *internalEnergyL = 0.0;
        *alpha = 0.0;
        *p = 0.0;
        *aG = 0.0;
        *aL = 0.0;
        *MG = 0.0;
        *ML = 0.0;

        return;
    }


    // mass fractions
    PetscReal Yg = PetscMin(1.0, PetscMax(0.0, densityVF / (*density)));
//    PetscReal Yg = densityVF / (*density);
//    PetscReal Yl = ((*density) - densityVF) / (*density);
    PetscReal Yl = 1.0 - Yg;

    PetscReal rhoL = NAN, rhoG = NAN, eG = NAN, eL = NAN;
    PetscReal TL = NAN, TG = NAN, pG = NAN, pL = NAN, alphaG = NAN;

    const PetscReal RG = eosGas->GetGasConstant();
    const PetscReal cpL = eosLiquid->GetSpecificHeatCp();
    const PetscReal p0L = eosLiquid->GetReferencePressure();
    const PetscReal gammaG = eosGas->GetSpecificHeatRatio();
    const PetscReal gammaL = eosLiquid->GetSpecificHeatRatio();
    const PetscReal cvG = RG / (gammaG - 1);
    const PetscReal cvL = cpL/gammaL;

    liquidEulerFieldScratch[CompressibleFlowFields::RHOE] = NAN;
    gasEulerFieldScratch[CompressibleFlowFields::RHOE] = NAN;
    for (PetscInt d = 0; d < dim; d++) {
        liquidEulerFieldScratch[CompressibleFlowFields::RHOU + d] = NAN;
        gasEulerFieldScratch[CompressibleFlowFields::RHOU + d] = NAN;
    }

//Yg = 2e-10;
//Yl = 1 - Yg;
//PetscReal densG = 1.1614401858304297, densL = 998.23;
//PetscReal gasE = cvG*300;
//PetscReal liqE = cvL*300 + p0L/densL;
// *internalEnergy = Yg*gasE + Yl*liqE;
// *density = 1/(Yg/densG + Yl/densL);

    if (Yg < 1e-8) { // All liquid
      rhoL = *density;
      TL = (*internalEnergy - p0L/rhoL)/cvL;

      liquidEulerFieldScratch[CompressibleFlowFields::RHO] = rhoL;
      liquidComputePressure.function(liquidEulerFieldScratch.data(), TL, &pL, liquidComputePressure.context.get()) >> utilities::PetscUtilities::checkError;

      TG = TL;
      pG = pL;

      rhoG = pG / (RG*TG);
      gasEulerFieldScratch[CompressibleFlowFields::RHO] = rhoG;

      alphaG = 0.0;
    }
    else if (Yl < 1e-8) { //All gas
      rhoG = *density;
      TG = *internalEnergy/cvG;

      gasEulerFieldScratch[CompressibleFlowFields::RHO] = rhoG;
      gasComputePressure.function(gasEulerFieldScratch.data(), TG, &pG, gasComputePressure.context.get()) >> utilities::PetscUtilities::checkError;

      TL = TG;
      pL = pG;

      rhoL = (pL + p0L)/((gammaL-1)*cvL*TL);
      liquidEulerFieldScratch[CompressibleFlowFields::RHO] = rhoL;

      alphaG = 1.0;
    }
    else {
      PetscReal e = *internalEnergy;
      PetscReal rho = *density;
      PetscReal A = rho*(cvG*Yg + cvL*Yl)*(cvG*gammaG*Yg + cvL*gammaL*Yl);
      PetscReal B = cvG*(p0L - e*(1 + gammaG)*rho)*Yg + cvL*(-(e*rho) + gammaL*(p0L - e*rho))*Yl;
      PetscReal C = e*(-p0L + e*rho);

      PetscReal x1, x2;
      SolveQuadratic(A, B, C, &x1, &x2);
      TG = TL = PetscMax(x1, x2);
      rhoL = gammaL*p0L*Yl/(e*gammaL - cvG*gammaL*TG*Yg - cpL*TL*Yl);
      rhoG = rho*rhoL*Yg/(rhoL - rho*Yl);

      liquidEulerFieldScratch[CompressibleFlowFields::RHO] = rhoL;
      gasEulerFieldScratch[CompressibleFlowFields::RHO] = rhoG;

      gasComputePressure.function(gasEulerFieldScratch.data(), TG, &pG, gasComputePressure.context.get()) >> utilities::PetscUtilities::checkError;
      liquidComputePressure.function(liquidEulerFieldScratch.data(), TL, &pL, liquidComputePressure.context.get()) >> utilities::PetscUtilities::checkError;

      alphaG = densityVF / rhoG;
    }



    liquidComputeInternalEnergy.function(liquidEulerFieldScratch.data(), TL, &eL, liquidComputeInternalEnergy.context.get()) >> utilities::PetscUtilities::checkError;
    gasComputeInternalEnergy.function(gasEulerFieldScratch.data(), TG, &eG, gasComputeInternalEnergy.context.get()) >> utilities::PetscUtilities::checkError;

    liquidComputeSpeedOfSound.function(liquidEulerFieldScratch.data(), TL, aL, liquidComputeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;
    gasComputeSpeedOfSound.function(gasEulerFieldScratch.data(), TG, aG, gasComputeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;


//printf("%+e\t%+e\t%+e\n", A, B, C);
//printf("%f\t%+e\n", TG, TG-300);
//NOTE0EXIT("%e\t%e\t%e\t%e\t%e\t%e\t%e\t%e\n", Yg, Yl, TG, TL, pG, pL, rhoG, rhoL);

if (alphaG < 0.5001){std::cout << "alpha rho rhoL rhoG Yl Yg pL pG  " << alphaG << " " << *density << " " << rhoL << " " << rhoG << " " << Yl << " " << Yg << " " << pL << " " << pG << "\n";}

    if (TL < PETSC_SMALL || TG < PETSC_SMALL) {
      printf("%e\t%e\n", Yg, Yl);
      printf("%e\t%e\n", TG, TL);
      throw std::runtime_error("Decode is returning negative temperature.\n");
    }

    if (pL < PETSC_SMALL || pG < PETSC_SMALL) {
      printf("  Y: %e\t%e\n", Yg, Yl);
      printf("  T: %f\t%f\n", TG, TL);
      printf("  p: %e\t%e\n", pG, pL);
      printf("rho: %e\t%e\n", rhoG, rhoL);
      printf("alpha: %e\n", alphaG);
      throw std::runtime_error("Decode is returning negative pressure.\n");
    }

    if (eL < PETSC_SMALL || eG < PETSC_SMALL) {
      printf("%e\t%e\n", Yg, Yl);
      printf("%e\t%e\n", eG, eL);
      throw std::runtime_error("Decode is returning negative energy.\n");
    }

    if (PetscAbsReal(TL - TG) > 1e-3*PetscMin(TL, TG)) {
      throw std::runtime_error("Decode is not returning temperature equilibrium.\n");
    }

    if (PetscAbsReal(pL - pG) > 1e-3*PetscMin(pL, pG)) {
      printf("%e\t%e\n", Yg, Yl);
      printf("%e\t%e\n", pG, pL);

//std::cout << "pg pL Yg Yl " << pG << " " << pL << " " << Yg << " " << Yl << "\n";

      throw std::runtime_error("Decode is not returning pressure equilibrium.\n");
    }

    // once state defined
    *alpha = PetscMin(1.0, PetscMax(0.0, alphaG));
//    *alpha = alphaG;
    *densityG = rhoG;
    *densityL = rhoL;
    *internalEnergyG = eG;
    *internalEnergyL = eL;
    *T = 0.5*(TG + TL);
    *p = 0.5*(pG + pL);  // pressure equilibrium, pG = pL
    *MG = (*normalVelocity) / (*aG);
    *ML = (*normalVelocity) / (*aL);

    PetscReal a1t = PetscSqrtReal((gammaG - 1) * cvG * (*T));
    PetscReal a2t = PetscSqrtReal((gammaL - 1) / gammaL * cpL * (*T));
    PetscReal ainv = Yg / (rhoG * rhoG * a1t * a1t) + Yl / (rhoL * rhoL * a2t * a2t);
    PetscReal amix = PetscSqrtReal(1 / ainv) / (*density);
    PetscReal bmodt = (*density) * amix * amix;
    if (bmodt < 0.0) {
        throw std::invalid_argument("isothermal bulk modulus of mixture negative");
    }

}
//*/

/**StiffenedGasStiffenedGasDecoder**************/
ablate::finiteVolume::processes::TwoPhaseEulerAdvection::StiffenedGasStiffenedGasDecoder::StiffenedGasStiffenedGasDecoder(PetscInt dim, const std::shared_ptr<eos::StiffenedGas> &eosGas,
                                                                                                                          const std::shared_ptr<eos::StiffenedGas> &eosLiquid)
    : eosGas(eosGas), eosLiquid(eosLiquid) {
    // Create the fake euler field
    auto fakeEulerField = ablate::domain::Field{.name = CompressibleFlowFields::EULER_FIELD,
                                                .numberComponents = 2 + dim,
                                                .components = {},
                                                .id = PETSC_DEFAULT,
                                                .subId = PETSC_DEFAULT,
                                                .offset = 0,
                                                .location = ablate::domain::FieldLocation::SOL,
                                                .type = ablate::domain::FieldType::FVM,
                                                .tags = {}};

    // size up the scratch vars
    gasEulerFieldScratch.resize(2 + dim);
    liquidEulerFieldScratch.resize(2 + dim);

    // extract/store compute calls
    gasComputeTemperature = eosGas->GetThermodynamicFunction(eos::ThermodynamicProperty::Temperature, {fakeEulerField});
    gasComputeInternalEnergy = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::InternalSensibleEnergy, {fakeEulerField});
    gasComputeSpeedOfSound = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::SpeedOfSound, {fakeEulerField});
    gasComputePressure = eosGas->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::Pressure, {fakeEulerField});

    liquidComputeTemperature = eosLiquid->GetThermodynamicFunction(eos::ThermodynamicProperty::Temperature, {fakeEulerField});
    liquidComputeInternalEnergy = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::InternalSensibleEnergy, {fakeEulerField});
    liquidComputeSpeedOfSound = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::SpeedOfSound, {fakeEulerField});
    liquidComputePressure = eosLiquid->GetThermodynamicTemperatureFunction(eos::ThermodynamicProperty::Pressure, {fakeEulerField});
}

void ablate::finiteVolume::processes::TwoPhaseEulerAdvection::StiffenedGasStiffenedGasDecoder::DecodeTwoPhaseEulerState(PetscInt dim, const PetscInt *uOff, const PetscReal *conservedValues,
                                                                                                                        const PetscReal *normal, PetscReal *density, PetscReal *densityG,
                                                                                                                        PetscReal *densityL, PetscReal *normalVelocity, PetscReal *velocity,
                                                                                                                        PetscReal *internalEnergy, PetscReal *internalEnergyG,
                                                                                                                        PetscReal *internalEnergyL, PetscReal *aG, PetscReal *aL, PetscReal *MG,
                                                                                                                        PetscReal *ML, PetscReal *p, PetscReal *T, PetscReal *alpha) {
    const int EULER_FIELD = 2;
    const int VF_FIELD = 1;

    // decode
    *density = conservedValues[CompressibleFlowFields::RHO + uOff[EULER_FIELD]];
    PetscReal totalEnergy = conservedValues[CompressibleFlowFields::RHOE + uOff[EULER_FIELD]] / (*density);
    PetscReal densityVF = conservedValues[uOff[VF_FIELD]];


    if (*density < PETSC_SMALL) { // This occurs when a cell hasn't been initialized yet. Usually FVM boundary cells
        *densityG = 0.0;
        *densityL = 0.0;
        *internalEnergyG = 0.0;
        *internalEnergyL = 0.0;
        *alpha = 0.0;
        *p = 0.0;
        *aG = 0.0;
        *aL = 0.0;
        *MG = 0.0;
        *ML = 0.0;

        return;
    }


    // Get the velocity in this direction, and kinetic energy
    (*normalVelocity) = 0.0;
    PetscReal ke = 0.0;
    for (PetscInt d = 0; d < dim; d++) {
        velocity[d] = conservedValues[CompressibleFlowFields::RHOU + d + uOff[EULER_FIELD]] / (*density);
        (*normalVelocity) += velocity[d] * normal[d];
        ke += PetscSqr(velocity[d]);
    }
    ke *= 0.5;
    (*internalEnergy) = (totalEnergy)-ke;

    PetscReal cp1 = eosGas->GetSpecificHeatCp();
    PetscReal cp2 = eosLiquid->GetSpecificHeatCp();
    PetscReal p01 = eosGas->GetReferencePressure();
    PetscReal p02 = eosLiquid->GetReferencePressure();
    PetscReal gamma1 = eosGas->GetSpecificHeatRatio();
    PetscReal gamma2 = eosLiquid->GetSpecificHeatRatio();

    DecodeDataStructStiff decodeDataStruct{
        .etot = (*internalEnergy),
        .rhotot = (*density),
        .Yg = densityVF / (*density),
        .Yl = ((*density) - densityVF) / (*density),
        .gam1 = gamma1,
        .gam2 = gamma2,
        .cpg = cp1,
        .cpl = cp2,
        .p0g = p01,
        .p0l = p02,
    };

    PetscReal rhoG = NAN, rhoL = NAN, eG = NAN, eL = NAN;

    if (decodeDataStruct.Yg < PETSC_SMALL || decodeDataStruct.Yl < PETSC_SMALL) {
        rhoL = decodeDataStruct.rhotot;
        eL = decodeDataStruct.etot;
        rhoG = decodeDataStruct.rhotot;
        eG = decodeDataStruct.etot;
    }
    else {
      SNES snes;
      Vec x, r;
      Mat J;
      VecCreate(PETSC_COMM_SELF, &x) >> utilities::PetscUtilities::checkError;
      VecSetSizes(x, PETSC_DECIDE, 4) >> utilities::PetscUtilities::checkError;
      VecSetFromOptions(x) >> utilities::PetscUtilities::checkError;

      // Set the initial guess to the conserved energy and the internal energy
      PetscScalar *ax;
      VecGetArray(x, &ax) >> utilities::PetscUtilities::checkError;
      ax[0] = decodeDataStruct.rhotot; // rho 1
      ax[1] = decodeDataStruct.rhotot; // rho 2
      ax[2] = decodeDataStruct.etot;   // e1
      ax[3] = decodeDataStruct.etot;   // e2
      VecRestoreArray(x, &ax) >> utilities::PetscUtilities::checkError;


      VecDuplicate(x, &r) >> utilities::PetscUtilities::checkError;

      MatCreate(PETSC_COMM_SELF, &J) >> utilities::PetscUtilities::checkError;
      MatSetSizes(J, 4, 4, 4, 4) >> utilities::PetscUtilities::checkError;
      MatSetType(J, MATDENSE) >> utilities::PetscUtilities::checkError; // The KSP fails is this isn't a dense matrix
      MatSetFromOptions(J) >> utilities::PetscUtilities::checkError;
      MatSetUp(J) >> utilities::PetscUtilities::checkError;

      SNESCreate(PETSC_COMM_SELF, &snes) >> utilities::PetscUtilities::checkError;
      SNESSetOptionsPrefix(snes, "gasSolver_");
      SNESSetFunction(snes, r, FormFunctionStiff, &decodeDataStruct) >> utilities::PetscUtilities::checkError;
      SNESSetJacobian(snes, J, J, FormJacobianStiff, &decodeDataStruct) >> utilities::PetscUtilities::checkError;
      SNESSetTolerances(snes, 1E-14, 1E-10, 1E-10, 1000, 10000) >> utilities::PetscUtilities::checkError;  // refine relative tolerance for more accurate pressure value
      SNESSetFromOptions(snes) >> utilities::PetscUtilities::checkError;
      SNESSolve(snes, NULL, x) >> utilities::PetscUtilities::checkError;

      SNESConvergedReason reason;
      SNESGetConvergedReason(snes, &reason) >> utilities::PetscUtilities::checkError;

      if (reason < 0 || reason == SNES_CONVERGED_ITS) {
        throw std::runtime_error("SNES for stiffened gas-stiffened gas decode failed.\n");
      }

      VecGetArray(x, &ax) >> utilities::PetscUtilities::checkError;
      rhoG = ax[0];
      rhoL = ax[1];
      eG   = ax[2];
      eL   = ax[3];
      VecRestoreArray(x, &ax) >> utilities::PetscUtilities::checkError;

      SNESDestroy(&snes) >> utilities::PetscUtilities::checkError;
      VecDestroy(&x) >> utilities::PetscUtilities::checkError;
      VecDestroy(&r) >> utilities::PetscUtilities::checkError;
      MatDestroy(&J) >> utilities::PetscUtilities::checkError;
    }

    PetscReal etG = eG + ke;
    PetscReal etL = eL + ke;

    PetscReal pG = 0;
    PetscReal pL = 0;
    PetscReal a1 = 0;
    PetscReal a2 = 0;

    // Fill the scratch array for gas
    liquidEulerFieldScratch[CompressibleFlowFields::RHO] = rhoL;
    liquidEulerFieldScratch[CompressibleFlowFields::RHOE] = rhoL * etL;
    for (PetscInt d = 0; d < dim; d++) {
        liquidEulerFieldScratch[CompressibleFlowFields::RHOU + d] = velocity[d] * rhoL;
    }

    // Fill the scratch array for gas
    gasEulerFieldScratch[CompressibleFlowFields::RHO] = rhoG;
    gasEulerFieldScratch[CompressibleFlowFields::RHOE] = rhoG * etG;
    for (PetscInt d = 0; d < dim; d++) {
        gasEulerFieldScratch[CompressibleFlowFields::RHOU + d] = velocity[d] * rhoG;
    }


    PetscReal TL = 0, TG = 0;
    liquidComputeTemperature.function(liquidEulerFieldScratch.data(), &TL, liquidComputeTemperature.context.get()) >> utilities::PetscUtilities::checkError;
    gasComputeTemperature.function(gasEulerFieldScratch.data(), &TG, gasComputeTemperature.context.get()) >> utilities::PetscUtilities::checkError;
    *T = 0.5*(TL + TG);

    // Decode the gas
    {
//        liquidComputeTemperature.function(liquidEulerFieldScratch.data(), T, liquidComputeTemperature.context.get()) >> utilities::PetscUtilities::checkError;
        liquidComputeInternalEnergy.function(liquidEulerFieldScratch.data(), *T, &eL, liquidComputeInternalEnergy.context.get()) >> utilities::PetscUtilities::checkError;
        liquidComputeSpeedOfSound.function(liquidEulerFieldScratch.data(), *T, &a2, liquidComputeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;
        liquidComputePressure.function(liquidEulerFieldScratch.data(), *T, &pL, liquidComputePressure.context.get()) >> utilities::PetscUtilities::checkError;
    }

    // Decode the gas
    {
//        gasComputeTemperature.function(gasEulerFieldScratch.data(), T, gasComputeTemperature.context.get()) >> utilities::PetscUtilities::checkError;
        gasComputeInternalEnergy.function(gasEulerFieldScratch.data(), *T, &eG, gasComputeInternalEnergy.context.get()) >> utilities::PetscUtilities::checkError;
        gasComputeSpeedOfSound.function(gasEulerFieldScratch.data(), *T, &a1, gasComputeSpeedOfSound.context.get()) >> utilities::PetscUtilities::checkError;
        gasComputePressure.function(gasEulerFieldScratch.data(), *T, &pG, gasComputePressure.context.get()) >> utilities::PetscUtilities::checkError;
    }

if (PetscAbsReal(pL - pG) > PetscMin(pG, pL)*PETSC_SMALL) printf("%e\t%e\t%e\n", pL, pG, PetscAbsReal(pL-pG));

    // once state defined
    *densityG = rhoG;
    *densityL = rhoL;
    *internalEnergyG = eG;
    *internalEnergyL = eL;
    *alpha = densityVF / (*densityG);
    *p = 0.5*(pL+pG);  // pressure equilibrium, pG = pL
    *aG = a1;
    *aL = a2;
    *MG = (*normalVelocity) / (*aG);
    *ML = (*normalVelocity) / (*aL);

}

#include "registrar.hpp"
REGISTER(ablate::finiteVolume::processes::Process, ablate::finiteVolume::processes::TwoPhaseEulerAdvection, "", ARG(ablate::eos::EOS, "eos", "must be twoPhase"),
         OPT(ablate::parameters::Parameters, "parameters", "the parameters used by advection: cfl(.5)"), ARG(ablate::finiteVolume::fluxCalculator::FluxCalculator, "fluxCalculatorGasGas", ""),
         ARG(ablate::finiteVolume::fluxCalculator::FluxCalculator, "fluxCalculatorGasLiquid", ""), ARG(ablate::finiteVolume::fluxCalculator::FluxCalculator, "fluxCalculatorLiquidGas", ""),
         ARG(ablate::finiteVolume::fluxCalculator::FluxCalculator, "fluxCalculatorLiquidLiquid", ""));
